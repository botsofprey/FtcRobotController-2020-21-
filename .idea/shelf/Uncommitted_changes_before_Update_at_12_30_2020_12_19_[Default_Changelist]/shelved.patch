Index: TeamCode/src/main/java/UserControlled/BasicDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage UserControlled;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.util.Range;\r\n\r\n@TeleOp(name=\"Basic: Linear OpMode\", group=\"Testers\")\r\n@Disabled\r\npublic class BasicDrive extends LinearOpMode {\r\n    // create objects and locally global variables here\r\n    DcMotor leftMotor, rightMotor;\r\n    double l, r;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        leftMotor = hardwareMap.dcMotor.get(\"leftMotor\");\r\n        rightMotor = hardwareMap.dcMotor.get(\"rightMotor\");\r\n        leftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        rightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        leftMotor.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        rightMotor.setDirection(DcMotorSimple.Direction.FORWARD);\r\n        // initialize objects and variables here\r\n        // also create and initialize function local variables here\r\n\r\n        // add any other useful telemetry data or logging data here\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.update();\r\n        // nothing goes between the above and below lines\r\n        waitForStart();\r\n        // should only be used for a time keeper or other small things, avoid using this space when possible\r\n        while (opModeIsActive()) {\r\n            // main code goes here\r\n\r\n            joystickDrive();\r\n            applyMotorPowers(l, r);\r\n\r\n            // telemetry and logging data goes here\r\n            telemetry.update();\r\n        }\r\n        // disable/kill/stop objects here\r\n    }\r\n    // misc functions here\r\n\r\n    private void tankDrive() {\r\n        l = 0;\r\n        r = 0;\r\n        if(gamepad1.right_trigger > 0.1) r = gamepad1.right_trigger;\r\n        else if(gamepad1.right_bumper) r = -1;\r\n        if(gamepad1.left_trigger > 0.1) l = gamepad1.left_trigger;\r\n        else if(gamepad1.left_bumper) l = -1;\r\n    }\r\n\r\n    private void tankJoystick() {\r\n        l = -gamepad1.left_stick_y;\r\n        r = -gamepad1.right_stick_y;\r\n    }\r\n\r\n    private void joystickDrive() {\r\n        double drive = -gamepad1.left_stick_y;\r\n        double turn  =  gamepad1.right_stick_x;\r\n        l    = Range.clip(drive + turn, -1.0, 1.0) ;\r\n        r   = Range.clip(drive - turn, -1.0, 1.0) ;\r\n    }\r\n\r\n    private void applyMotorPowers(double left, double right) {\r\n        leftMotor.setPower(left);\r\n        rightMotor.setPower(right);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/BasicDrive.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/UserControlled/BasicDrive.java	(date 1608578744826)
@@ -36,7 +36,7 @@
 import com.qualcomm.robotcore.hardware.DcMotorSimple;
 import com.qualcomm.robotcore.util.Range;
 
-@TeleOp(name="Basic: Linear OpMode", group="Testers")
+@TeleOp(name="Basic Drive", group="Testers")
 @Disabled
 public class BasicDrive extends LinearOpMode {
     // create objects and locally global variables here
Index: TeamCode/src/main/java/UserControlled/GamepadControllerTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage UserControlled;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\n\r\n@TeleOp(name=\"Gamepad Controller Test\", group=\"Testers\")\r\n//@Disabled\r\npublic class GamepadControllerTest extends LinearOpMode {\r\n    // create objects and locally global variables here\r\n\r\n    GamepadController controller;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        // initialize objects and variables here\r\n        // also create and initialize function local variables here\r\n\r\n        telemetry.addData(\"Test\", \"1\");\r\n\r\n        controller = new GamepadController(gamepad1);\r\n\r\n        // add any other useful telemetry data or logging data here\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.addData(\"Another test\", \"2\");\r\n        telemetry.update();\r\n\r\n        // nothing goes between the above and below lines\r\n\r\n        waitForStart();\r\n\r\n        int timesPressed = 0;\r\n        int timesHeld = 0;\r\n\r\n        // should only be used for a time keeper or other small things, avoid using this space when possible\r\n        while (opModeIsActive()) {\r\n            // main code goes here\r\n\r\n            controller.update(gamepad1);\r\n\r\n            if (controller.aPressed()) timesPressed++;\r\n            if (controller.aHeld()) timesHeld++;\r\n\r\n            telemetry.addData(\"Times Pressed\", timesPressed);\r\n            telemetry.addData(\"Times Held\", timesHeld);\r\n\r\n            // telemetry and logging data goes here\r\n            telemetry.update();\r\n        }\r\n        // disable/kill/stop objects here\r\n    }\r\n    // misc functions here\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/GamepadControllerTest.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/UserControlled/GamepadControllerTest.java	(date 1608578804534)
@@ -64,7 +64,7 @@
         while (opModeIsActive()) {
             // main code goes here
 
-            controller.update(gamepad1);
+            controller.update();
 
             if (controller.aPressed()) timesPressed++;
             if (controller.aHeld()) timesHeld++;
Index: TeamCode/src/main/java/UserControlled/SystemsTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage UserControlled;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\n\r\n@TeleOp(name=\"Systems Test\", group=\"Competition\")\r\n//@Disabled\r\npublic class SystemsTest extends LinearOpMode {\r\n    // create objects and locally global variables here\r\n\r\n    GamepadController controller;\r\n\r\n    private Servo aimServo;\r\n\r\n    // TODO get numbers for these variables\r\n    private static final double TOP_GOAL_POSITION = 1;\r\n    private static final double POWER_SHOT_POSITION = 0.8;\r\n    private static final double LOWERED_POSITION = 0.5;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n\r\n        controller = new GamepadController(gamepad1);\r\n\r\n        aimServo = hardwareMap.servo.get(\"aimServo\");\r\n        aimServo.setPosition(1);\r\n\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.update();\r\n\r\n        waitForStart();\r\n\r\n        while(opModeIsActive()) {\r\n            controller.update(gamepad1);\r\n\r\n            if (controller.dpadUpPressed())\r\n                aimServo.setPosition(aimServo.getPosition() - 0.05);\r\n            if (controller.dpadDownPressed())\r\n                aimServo.setPosition(aimServo.getPosition() + 0.05);\r\n\r\n            telemetry.addData(\"Servo Angle\", aimServo.getPosition());\r\n            telemetry.update();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/SystemsTest.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/UserControlled/SystemsTest.java	(date 1608578812113)
@@ -61,7 +61,7 @@
         waitForStart();
 
         while(opModeIsActive()) {
-            controller.update(gamepad1);
+            controller.update();
 
             if (controller.dpadUpPressed())
                 aimServo.setPosition(aimServo.getPosition() - 0.05);
Index: TeamCode/src/main/java/DriveEngine/Ultimate/UltimateNavigation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package DriveEngine.Ultimate;\r\n\r\nimport android.util.Log;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.HashMap;\r\n\r\nimport Autonomous.HeadingVector;\r\nimport Autonomous.Location;\r\nimport Autonomous.Rectangle;\r\nimport MotorControllers.JsonConfigReader;\r\nimport MotorControllers.MotorController;\r\nimport MotorControllers.PIDController;\r\nimport SensorHandlers.ImuHandler;\r\nimport SensorHandlers.LIDARSensor;\r\n\r\n/**\r\n * Created by Jeremy on 8/23/2017.\r\n * Updated by Ethan Fisher on 10/29/2020\r\n *\r\n * The base class for every opmode --- it sets up our drive system and contains all it's funcitons\r\n */\r\npublic class UltimateNavigation extends Thread {\r\n\r\n    public static final Rectangle NO_GO_ZONE = new Rectangle(0, 0, 144, 48);\r\n\r\n    private static final double GOOD_DIST_READING_TOLERANCE = 72.0;\r\n\r\n    public MotorController[] driveMotors = new MotorController[4];\r\n    public static final int FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR = 0;\r\n    public static final int FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR = 1;\r\n    public static final int BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR = 2;\r\n    public static final int BACK_LEFT_HOLONOMIC_DRIVE_MOTOR = 3;\r\n\r\n    public static final double LOCATION_DISTANCE_TOLERANCE = 0.75, ROUGH_LOCATION_DISTANCE_TOLERANCE = 1.5, STOPPING_DISTANCE_FACTOR = 0.2;\r\n    public static final double LIDAR_DISTANCE_TOLERANCE = 15.0;\r\n    public static final long TIME_TOLERANCE = 250;\r\n    public static final long DEFAULT_DELAY_MILLIS = 10;\r\n\r\n    public static final double FORWARD = 0;\r\n    public static final double RIGHT = 90;\r\n    public static final double BACK = 180;\r\n    public static final double LEFT = -90;\r\n\r\n    private volatile long threadDelayMillis = 10;\r\n\r\n    private volatile double [] lastMotorPositionsInInches = { 0, 0, 0, 0 };\r\n\r\n    public PIDController headingController, turnController, cameraTranslationYController,\r\n            cameraTranslationXController, cameraOrientationController, xPositionController, yPositionController;\r\n\r\n    private volatile Location myLocation;\r\n    private volatile double startHeading;\r\n    private volatile HeadingVector[] wheelVectors;\r\n    private volatile HeadingVector robotMovementVector = new HeadingVector();\r\n    public ImuHandler orientation;\r\n    private double orientationOffset = 0;\r\n\r\n    private volatile boolean shouldRun = true, loggingData = true, usingSensors = true;\r\n    private volatile long startTime = System.nanoTime();\r\n    private volatile HeadingVector IMUTravelVector = new HeadingVector();\r\n    public static double MAX_SPEED = 25.0;  // inches / second\r\n\r\n    private volatile Location IMUDistance = new Location(0, 0);\r\n\r\n    private LIDARSensor[] distanceSensors;\r\n    private static final int LEFT_SENSOR = 0, BACK_SENSOR = 1, RIGHT_SENSOR = 2, DRIVE_BASE = 3, FRONT_SENSOR = 4;\r\n    private HashMap<Integer, int[]>[] updateLocationInformation = new HashMap[4]; // structure: {direction, {xSensor, ySensor}}\r\n\r\n    public static final int Q1 = 0, Q2 = 1, Q3 = 2, Q4 = 3,\r\n            NORTH = 0, SOUTH = 180, EAST = 90, WEST = 270;\r\n\r\n    private final double HEADING_THRESHOLD = 2;\r\n    private final double WHEEL_BASE_RADIUS = 20;\r\n    private final double FL_WHEEL_HEADING_OFFSET = 45;\r\n    private final double FR_WHEEL_HEADING_OFFSET = 315;\r\n    private final double BR_WHEEL_HEADING_OFFSET = 45;\r\n    private final double BL_WHEEL_HEADING_OFFSET = 315;\r\n\r\n    private HardwareMap hardwareMap;\r\n\r\n    public UltimateNavigation(HardwareMap hw, Location startLocation, String configFile, boolean ignoreInitialSensorLocation) {\r\n        hardwareMap = hw;\r\n        initializeUsingConfigFile(configFile);\r\n        orientationOffset = startLocation.getHeading();\r\n        orientation = new ImuHandler(\"imu\", orientationOffset, hardwareMap);\r\n        myLocation = startLocation;\r\n\r\n//        distanceSensors = new LIDARSensor[3];\r\n//        distanceSensors[LEFT_SENSOR] = new LIDARSensor(hardwareMap.get(DistanceSensor.class, \"left\"), LEFT_SENSOR, \"left\");\r\n//        distanceSensors[BACK_SENSOR] = new LIDARSensor(hardwareMap.get(DistanceSensor.class, \"back\"), BACK_SENSOR, \"back\");\r\n//        distanceSensors[RIGHT_SENSOR] = new LIDARSensor(hardwareMap.get(DistanceSensor.class, \"right\"), RIGHT_SENSOR, \"right\");\r\n\r\n//        if (!ignoreInitialSensorLocation) getInitialLocation();\r\n\r\n        wheelVectors = new HeadingVector[4];\r\n        for (int i = 0; i < wheelVectors.length; i++)\r\n            wheelVectors[i] = new HeadingVector();\r\n\r\n        for (int i = 0; i < lastMotorPositionsInInches.length; i ++)\r\n            lastMotorPositionsInInches[i] = driveMotors[i].getInchesFromStart();\r\n\r\n        robotMovementVector = new HeadingVector();\r\n        startTime = System.nanoTime();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i < driveMotors.length; i++) {\r\n                    Log.d(\"Inch from start\", i + \": \" + driveMotors[i].getInchesFromStart());\r\n                }\r\n                while (shouldRun) {\r\n                    try {\r\n                        updateData();\r\n                    }\r\n                    catch (Exception e) {\r\n                        shouldRun = false;\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                    safetySleep(threadDelayMillis);\r\n                }\r\n            }\r\n        }).start();\r\n    }\r\n\r\n    public UltimateNavigation(HardwareMap hw, Location startLocation, String configFile) {\r\n        this(hw, startLocation, configFile, false);\r\n    }\r\n\r\n//    private void getInitialLocation() {\r\n//        // SOME LOGICAL ERROR IN FINDING QUADRANT MOST LIKELY -- CHECK HASHTABLE FOR LOCATION CHECKS\r\n//        int quadrant = -1;\r\n//        if(myLocation.getX() >= 0 && myLocation.getY() >= 0) quadrant = Q1;\r\n//        else if(myLocation.getX() < 0 && myLocation.getY() >= 0) quadrant = Q2;\r\n//        else if(myLocation.getX() < 0 && myLocation.getY() < 0) quadrant = Q3;\r\n//        else if(myLocation.getX() >= 0 && myLocation.getY() < 0) quadrant = Q4;\r\n//        Log.d(\"Quadrant: \", \"\"+quadrant);\r\n//\r\n//        double simpleHeading = myLocation.getHeading() % 360;\r\n//        int dir = -1;\r\n//        if(simpleHeading < 1 && simpleHeading > -1) dir = NORTH;\r\n//        else if(simpleHeading < 91 && simpleHeading > 89) dir = EAST; // REVIEW: suggest to define HEADING_TOLERANCE = 1 and use abs(simpleHeading - 90) < HEADING_TOLERANCE\r\n//        else if(simpleHeading < 181 && simpleHeading > 179) dir = SOUTH;\r\n//        else if(simpleHeading < 271 && simpleHeading > 269) dir = WEST;\r\n//        Log.d(\"Direction: \", \"\"+dir);\r\n//\r\n//        int[] sensorsToUse = updateLocationInformation[quadrant].get(dir);\r\n//        if (sensorsToUse != null && sensorsToUse[0] != DRIVE_BASE) {\r\n//            double x = 71.0 - distanceSensors[sensorsToUse[0]].getDistance() - 7.0;\r\n//            x *= quadrant == Q2 || quadrant == Q3 ? -1 : 1; //TODO this is wrong I'm pretty sure\r\n//            Log.d(\"Start sensor X: \", \"\" + x);\r\n//            Log.d(\"Start loc X: \", myLocation.getX()+\"\");\r\n//            if (Math.abs(myLocation.getX() - x) < 50) myLocation.setX(x);\r\n//        }\r\n//        if (sensorsToUse != null && sensorsToUse[1] != DRIVE_BASE) {\r\n//            double y = 71.0 - distanceSensors[sensorsToUse[1]].getDistance() - 7.0;\r\n//            y *= quadrant == Q3 || quadrant == Q4 ? -1 : 1;\r\n//            Log.d(\"Start sensor Y: \", \"\" + y);\r\n//            Log.d(\"Start loc Y:\", myLocation.getY()+\"\");\r\n//            if (Math.abs(myLocation.getY() - y) < 50) myLocation.setY(y);\r\n//        }\r\n//        // TODO how can we stop both run and logcat from filling up with IMU Locations? It's really annoying cuz i can't see what's printed out from AnnieNavigation -- type in your filter, right now its location...\r\n//    }\r\n\r\n    public void stopLoggingData() {\r\n        loggingData = false;\r\n    }\r\n\r\n    public void startLoggingData() {\r\n        loggingData = true;\r\n    }\r\n\r\n    public void useSensorLocationTracking() {\r\n        usingSensors = true;\r\n    }\r\n\r\n    public void disableSensorLocationTracking() {\r\n        usingSensors = false;\r\n    }\r\n\r\n    public void setOrientationOffset(double offset) {\r\n        orientation.setOrientationOffset(orientationOffset = offset);\r\n    }\r\n\r\n    private void updateLastMotorPositionsInInches() {\r\n        for (int i = 0; i < driveMotors.length; i++)\r\n            lastMotorPositionsInInches[i] = driveMotors[i].getInchesFromStart();\r\n    }\r\n\r\n    private double getRobotHeading() { return orientation.getOrientation(); }\r\n\r\n    public Location getRobotLocation() {\r\n        return new Location(myLocation.getX(), myLocation.getY(), myLocation.getHeading());\r\n    }\r\n\r\n//    private void updateLocation() {\r\n//        boolean shouldTranslateX = false, shouldTranslateY = false;\r\n//        double expectedY, expectedX;\r\n//        double simpleHeading = getRobotHeading() % 360;\r\n//\r\n//        // sensor location tracking\r\n//        int quadrant = -1;\r\n//        if(myLocation.getX() >= 0 && myLocation.getY() >= 0) quadrant = Q1;\r\n//        else if(myLocation.getX() < 0 && myLocation.getY() >= 0) quadrant = Q2;\r\n//        else if(myLocation.getX() < 0 && myLocation.getY() < 0) quadrant = Q3;\r\n//        else if(myLocation.getX() >= 0 && myLocation.getY() < 0) quadrant = Q4;\r\n//        int dir = -1;\r\n//        if(simpleHeading < 2.5 && simpleHeading > -2.5) dir = NORTH;\r\n//        else if(simpleHeading < 92.5 && simpleHeading > 87.5) dir = EAST; // REVIEW: suggest to define HEADING_TOLERANCE = 1 and use abs(simpleHeading - 90) < HEADING_TOLERANCE\r\n//        else if(simpleHeading < 182.5 && simpleHeading > 177.5) dir = SOUTH;\r\n//        else if(simpleHeading < 272.5 && simpleHeading > 267.5) dir = WEST;\r\n//        else {\r\n//            // if not lined up to a square direction, then just use wheel odometry to track position\r\n//            shouldTranslateX = true;\r\n//            shouldTranslateY = true;\r\n//        }\r\n//\r\n//        // wheel location tracking\r\n//        HeadingVector travelVector = wheelVectors[0].addVectors(wheelVectors);\r\n//        travelVector = new HeadingVector(travelVector.x() / 2, travelVector.y() / 2);\r\n//        double headingOfRobot = travelVector.getHeading();\r\n//        double magnitudeOfRobot = travelVector.getMagnitude();\r\n//        double actualHeading = (headingOfRobot + getRobotHeading()) % 360;\r\n//        robotMovementVector.calculateVector(actualHeading, magnitudeOfRobot);\r\n//        double deltaX = robotMovementVector.x();\r\n//        double deltaY = robotMovementVector.y();\r\n//\r\n//        if (!myLocation.withinRectangle(NO_GO_ZONE) && usingSensors) {\r\n//            if (!shouldTranslateX) {\r\n//                int[] sensorsToUse = updateLocationInformation[quadrant].get(dir);\r\n//                if (sensorsToUse != null && sensorsToUse[0] == DRIVE_BASE) shouldTranslateX = true;\r\n//                else if (sensorsToUse != null && sensorsToUse[1] == DRIVE_BASE)\r\n//                    shouldTranslateY = true;\r\n//                if (!shouldTranslateX &&\r\n//                        (myLocation.withinRectangle(ConfigVariables.VALID_X_SENSOR_READ_AREA_1_RED) || myLocation.withinRectangle(ConfigVariables.VALID_X_SENSOR_READ_AREA_2_RED)\r\n//                        || myLocation.withinRectangle(ConfigVariables.VALID_X_SENSOR_READ_AREA_1_BLUE) || myLocation.withinRectangle(ConfigVariables.VALID_X_SENSOR_READ_AREA_2_BLUE))) {\r\n//                    // REVIEW: there are several conditions to check to determine if a distance reading is good, so\r\n//                    // is is best to encapsulate this in a class.  I suggest to have a sensor.getGoodDistance()\r\n//                    // function that returns a Double distance or null, if a good distances isn't available.\r\n//                    // Then, have a separate function that can be called in the null case, for example sensor.explainNull()\r\n//                    // to get a message describing the problem, which can be reported in telemetry or logs.\r\n//                    // An alternate implementation would have getDistance() return a double only if a good distance is\r\n//                    // available and throw InvalidDistanceException otherwise.  Then, this code can catch the exception\r\n//                    // to report in telemetry or logs.\r\n//                    Double dist = distanceSensors[sensorsToUse[0]].getGoodDistance();\r\n//                    Log.d(\"X sensor dist: \", dist+\"\");\r\n//                    if (dist != null && dist < GOOD_DIST_READING_TOLERANCE) {\r\n//                        // REVIEW: the magic numbers in the following formula should be pulled out as named constants\r\n//                        expectedX = 71.0 - dist - 7.0;\r\n//                        if (quadrant == Q2 || quadrant == Q3) expectedX *= -1;\r\n//                        if (Math.abs(expectedX - (myLocation.getX() + deltaX)) <= LIDAR_DISTANCE_TOLERANCE)\r\n//                            myLocation.setX(expectedX);\r\n//                        else shouldTranslateX = true;\r\n//                    } else {\r\n//                        shouldTranslateX = true;\r\n//                    }\r\n//                } else shouldTranslateX = true;\r\n//                if (!shouldTranslateY &&\r\n//                        (myLocation.withinRectangle(ConfigVariables.VALID_Y_SENSOR_READ_AREA_1_RED) || myLocation.withinRectangle(ConfigVariables.VALID_Y_SENSOR_READ_AREA_2_RED)\r\n//                        || myLocation.withinRectangle(ConfigVariables.VALID_Y_SENSOR_READ_AREA_1_BLUE) || myLocation.withinRectangle(ConfigVariables.VALID_Y_SENSOR_READ_AREA_2_BLUE))) {\r\n//                    Double dist = distanceSensors[sensorsToUse[1]].getGoodDistance();\r\n//                    if (dist != null && dist < GOOD_DIST_READING_TOLERANCE) {\r\n//                        expectedY = 71.0 - dist - 7.0;\r\n//                        if (quadrant == Q3 || quadrant == Q4) expectedY *= -1;\r\n//                        myLocation.setY(expectedY);\r\n//                        if (Math.abs(expectedY - (myLocation.getY() + deltaY)) <= LIDAR_DISTANCE_TOLERANCE)\r\n//                            myLocation.setY(expectedY);\r\n//                        else shouldTranslateY = true;\r\n//                    } else {\r\n//                        shouldTranslateY = true;\r\n//                    }\r\n//                } else shouldTranslateY = true;\r\n//            }\r\n//        }else{\r\n//            shouldTranslateX = shouldTranslateY = true;\r\n//        }\r\n//        if(shouldTranslateX) myLocation.addX(deltaX);\r\n//        if(shouldTranslateY) myLocation.addY(deltaY);\r\n//        myLocation.setHeading(restrictAngle(orientation.getOrientation(), 0));\r\n//        Log.d(\"Location\", \"X:\" + myLocation.getX() + \" Y:\" + myLocation.getY());\r\n//        Log.d(\"Sensor X:\", shouldTranslateX ? \"ENCODER\" : \"LIDAR\");\r\n//        Log.d(\"Sensor Y:\", shouldTranslateY ? \"ENCODER\" : \"LIDAR\");\r\n//    }\r\n\r\n    private void updateLocation() {\r\n        HeadingVector travelVector = wheelVectors[0].addVectors(wheelVectors);\r\n        travelVector = new HeadingVector(travelVector.x() / 2, travelVector.y() / 2);\r\n        double headingOfRobot = travelVector.getHeading();\r\n        double magnitudeOfRobot = travelVector.getMagnitude();\r\n        double actualHeading = (headingOfRobot + getRobotHeading()) % 360;\r\n        robotMovementVector.calculateVector(actualHeading, magnitudeOfRobot);\r\n        double deltaX = robotMovementVector.x();\r\n        double deltaY = robotMovementVector.y();\r\n        myLocation.addX(deltaX);\r\n        myLocation.addY(deltaY);\r\n        myLocation.setHeading(orientation.getOrientation());\r\n        Log.d(\"Location\", \"X:\" + myLocation.getX() + \" Y:\" + myLocation.getY() + \" Heading:\" + myLocation.getHeading());\r\n    }\r\n    private double restrictAngle(double angleToChange, double referenceAngle) {\r\n        while(angleToChange < referenceAngle - 180) angleToChange += 360;\r\n        while (angleToChange > referenceAngle + 180) angleToChange -= 360;\r\n        return angleToChange;\r\n    }\r\n\r\n    private void updateIMUTrackedDistance() {\r\n        double deltaTime = (System.nanoTime() - startTime) * (1.0/1.0e9);\r\n\r\n        HeadingVector travelVector = new HeadingVector(orientation.getAccelerations()[0], orientation.getAccelerations()[1]);\r\n        double accelerationHeading = travelVector.getHeading();\r\n        double accelerationMagnitude = travelVector.getMagnitude();\r\n        double actualHeading = (accelerationHeading + getRobotHeading())%360;\r\n        IMUTravelVector.calculateVector(actualHeading, accelerationMagnitude);\r\n        double deltaX = 0.5*IMUTravelVector.x()*deltaTime;\r\n        double deltaY = 0.5*IMUTravelVector.y()*deltaTime;\r\n        IMUDistance.addXY(deltaX, deltaY);\r\n\r\n        Log.d(\"IMU Distance: \", \"\" + IMUDistance.distanceToLocation(new Location(0, 0)));\r\n        Log.d(\"IMU Location: \", IMUDistance.toString());\r\n\r\n        startTime = System.nanoTime();\r\n    }\r\n\r\n//    public void setLocation(Location loc) { myLocation = new Location(loc.getX(), loc.getY()); }\r\n\r\n    private void updateData() {\r\n\r\n        getRobotHeading();\r\n        wheelVectors = getWheelVectors();\r\n        updateLocation();\r\n        updateIMUTrackedDistance();\r\n    }\r\n\r\n    private void safetySleep(long time){\r\n        long start = System.currentTimeMillis();\r\n        while (System.currentTimeMillis() - start < time && shouldRun);\r\n    }\r\n\r\n    public void initializeUsingConfigFile(String file) {\r\n        InputStream stream = null;\r\n        try {\r\n            stream = hardwareMap.appContext.getAssets().open(file);\r\n        }\r\n        catch(Exception e){\r\n            Log.d(\"Drive Engine Error: \",e.toString());\r\n            throw new RuntimeException(\"Drive Engine Open Config File Fail: \" + e.toString());\r\n        }\r\n        JsonConfigReader reader = new JsonConfigReader(stream);\r\n        try {\r\n            driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = new MotorController(reader.getString(\"FRONT_LEFT_MOTOR_NAME\"), \"MotorConfig/DriveMotors/NewHolonomicDriveMotorConfig.json\", hardwareMap);\r\n            driveMotors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = new MotorController(reader.getString(\"FRONT_RIGHT_MOTOR_NAME\"), \"MotorConfig/DriveMotors/NewHolonomicDriveMotorConfig.json\", hardwareMap);\r\n            driveMotors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = new MotorController(reader.getString(\"BACK_LEFT_MOTOR_NAME\"), \"MotorConfig/DriveMotors/NewHolonomicDriveMotorConfig.json\", hardwareMap);\r\n            driveMotors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = new MotorController(reader.getString(\"BACK_RIGHT_MOTOR_NAME\"), \"MotorConfig/DriveMotors/NewHolonomicDriveMotorConfig.json\", hardwareMap);\r\n            for (int i = 0; i < driveMotors.length; i++) {\r\n                driveMotors[i].setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n                driveMotors[i].setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n            }\r\n            if(reader.getString(\"DRIVE_MOTOR_BRAKING_MODE\").equals(\"BRAKE\")) {\r\n                for (int i = 0; i < driveMotors.length; i++) {\r\n                    driveMotors[i].setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n                }\r\n            }\r\n            else if(reader.getString(\"DRIVE_MOTOR_BRAKING_MODE\").equals(\"FLOAT\")) {\r\n                for (int i = 0; i < driveMotors.length; i++) {\r\n                    driveMotors[i].setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\r\n                }\r\n            }\r\n            if(reader.getString(\"FRONT_LEFT_MOTOR_DIRECTION\").equals(\"REVERSE\")) {\r\n                driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.REVERSE);\r\n            }\r\n            else if(reader.getString(\"FRONT_LEFT_MOTOR_DIRECTION\").equals(\"FORWARD\")) {\r\n                driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.FORWARD);\r\n            }\r\n            if(reader.getString(\"FRONT_RIGHT_MOTOR_DIRECTION\").equals(\"REVERSE\")) {\r\n                driveMotors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.REVERSE);\r\n            }\r\n            else if(reader.getString(\"FRONT_RIGHT_MOTOR_DIRECTION\").equals(\"FORWARD\")) {\r\n                driveMotors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.FORWARD);\r\n            }\r\n            if(reader.getString(\"BACK_RIGHT_MOTOR_DIRECTION\").equals(\"REVERSE\")) {\r\n                driveMotors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.REVERSE);\r\n            }\r\n            else if(reader.getString(\"BACK_RIGHT_MOTOR_DIRECTION\").equals(\"FORWARD\")) {\r\n                driveMotors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.FORWARD);\r\n            }\r\n            if (reader.getString(\"BACK_LEFT_MOTOR_DIRECTION\").equals(\"REVERSE\")) {\r\n                driveMotors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.REVERSE);\r\n            }\r\n            else if (reader.getString(\"BACK_LEFT_MOTOR_DIRECTION\").equals(\"FORWARD\")) {\r\n                driveMotors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR].setDirection(DcMotorSimple.Direction.FORWARD);\r\n            }\r\n            headingController = new PIDController(reader.getDouble(\"HEADING_Kp\"), reader.getDouble(\"HEADING_Ki\"), reader.getDouble(\"HEADING_Kd\"));\r\n            headingController.setIMax(reader.getDouble(\"HEADING_Ki_MAX\"));\r\n            turnController = new PIDController(reader.getDouble(\"TURN_Kp\"), reader.getDouble(\"TURN_Ki\"), reader.getDouble(\"TURN_Kd\"));\r\n            turnController.setIMax(reader.getDouble(\"TURN_Ki_MAX\"));\r\n            cameraTranslationYController = new PIDController(reader.getDouble(\"CAMERA_TRANSLATION_Y_Kp\"), reader.getDouble(\"CAMERA_TRANSLATION_Y_Ki\"), reader.getDouble(\"CAMERA_TRANSLATION_Y_Kd\"));\r\n            cameraTranslationYController.setIMax(reader.getDouble(\"CAMERA_TRANSLATION_Y_Ki_MAX\"));\r\n            cameraTranslationXController = new PIDController(reader.getDouble(\"CAMERA_TRANSLATION_X_Kp\"), reader.getDouble(\"CAMERA_TRANSLATION_X_Ki\"), reader.getDouble(\"CAMERA_TRANSLATION_X_Kd\"));\r\n            cameraTranslationXController.setIMax(reader.getDouble(\"CAMERA_TRANSLATION_X_Ki_MAX\"));\r\n            cameraOrientationController = new PIDController(reader.getDouble(\"CAMERA_ORIENTATION_Kp\"), reader.getDouble(\"CAMERA_ORIENTATION_Ki\"), reader.getDouble(\"CAMERA_ORIENTATION_Kd\"));\r\n            cameraOrientationController.setIMax(reader.getDouble(\"CAMERA_ORIENTATION_Ki_MAX\"));\r\n            xPositionController = new PIDController(reader.getDouble(\"X_POSITION_Kp\"), reader.getDouble(\"X_POSITION_Ki\"), reader.getDouble(\"X_POSITION_Kd\"));\r\n            yPositionController = new PIDController(reader.getDouble(\"Y_POSITION_Kp\"), reader.getDouble(\"Y_POSITION_Ki\"), reader.getDouble(\"Y_POSITION_Kd\"));\r\n            xPositionController.setIMax(reader.getDouble(\"X_POSITION_Ki_MAX\"));\r\n            yPositionController.setIMax(reader.getDouble(\"Y_POSITION_Ki_MAX\"));\r\n        } catch(Exception e){\r\n            Log.e(\" Drive Engine Error\", \"Config File Read Fail: \" + e.toString());\r\n            throw new RuntimeException(\"Drive Engine Config Read Failed!:\" + e.toString());\r\n        }\r\n    }\r\n\r\n    public void correctedDriveOnHeadingIMU(double heading, double desiredVelocity, LinearOpMode mode) {\r\n        correctedDriveOnHeadingIMU(heading,desiredVelocity,DEFAULT_DELAY_MILLIS,mode);\r\n    }\r\n\r\n    public void correctedDriveOnHeadingIMU(double heading, double desiredVelocity, long delayTimeMillis, LinearOpMode mode) {\r\n        desiredVelocity = Math.abs(desiredVelocity);\r\n        double curOrientation = orientation.getOrientation();\r\n        double distanceFromHeading = 0;\r\n        distanceFromHeading = heading - curOrientation; // as in -1 if heading is 0 and current orientation is 1\r\n        if(distanceFromHeading > 180) distanceFromHeading -= 360;\r\n        if(distanceFromHeading < -180) distanceFromHeading += 360;\r\n        if(curOrientation > 315 || curOrientation <= 45){\r\n            headingController.setSp(0);\r\n        }\r\n        else if(curOrientation > 45 && curOrientation <= 135){\r\n            headingController.setSp(90);\r\n        }\r\n        else if(curOrientation > 135 && curOrientation <= 225){\r\n            headingController.setSp(180);\r\n        }\r\n        else if(curOrientation > 225 && curOrientation <= 315){\r\n            headingController.setSp(270);\r\n        }\r\n        double distanceFromSetPoint = headingController.getSp() - curOrientation;\r\n        if(distanceFromSetPoint < -180) distanceFromSetPoint += 360;\r\n        else if(distanceFromSetPoint > 180) distanceFromSetPoint -= 360;\r\n        double deltaVelocity = headingController.calculatePID(distanceFromSetPoint + headingController.getSp()); //isue with this line...\r\n        if(distanceFromHeading < 0) distanceFromHeading += 360;\r\n        else if(distanceFromHeading > 360) distanceFromHeading -= 360;\r\n        double [] velocities = determineMotorVelocitiesToDriveOnHeading(heading - curOrientation,desiredVelocity);\r\n\r\n        if(distanceFromHeading > 315 || distanceFromHeading <= 45){\r\n            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n        }\r\n\r\n        else if(distanceFromHeading > 45 && distanceFromHeading <= 135){\r\n            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n        }\r\n\r\n        else if(distanceFromHeading > 135 && distanceFromHeading <= 225){\r\n            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n        }\r\n\r\n        else if(distanceFromHeading > 225 && distanceFromHeading <= 315){\r\n            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n        }\r\n\r\n        applyMotorVelocities(velocities);\r\n        mode.sleep(delayTimeMillis);\r\n    }\r\n\r\n    public void correctedDriveOnHeadingIMURotation(double heading, double desiredVelocity, long delayTimeMillis, LinearOpMode mode) {\r\n        desiredVelocity = Math.abs(desiredVelocity);\r\n        double curOrientation = orientation.getOrientation();\r\n        double turnCorrection = turnController.calculatePID(curOrientation);\r\n        if(Double.isNaN(turnCorrection)) turnCorrection = 0;\r\n        Log.d(\"Delta Velocity:\", \"\" + turnCorrection);\r\n        double [] velocities = determineMotorVelocitiesToDriveOnHeading(heading/* - curOrientation*/, desiredVelocity);\r\n\r\n        Log.d(\"Initial Velocities:\", \"-----------\");\r\n        for(int i = 0; i < velocities.length; i++) {\r\n            Log.d(\"Motor \" + \" Velocity\", \"\" + velocities[i]);\r\n        }\r\n\r\n        double [] rotationalCorrections = calculateTurnVelocities(turnCorrection);\r\n        for(int i = 0; i < driveMotors.length; i++) {\r\n            velocities[i] += rotationalCorrections[i];\r\n        }\r\n\r\n        Log.d(\"Final Velocities:\", \"-----------\");\r\n        for(int i = 0; i < velocities.length; i++) {\r\n            Log.d(\"Motor \" + \" Velocity\", \"\" + velocities[i]);\r\n        }\r\n\r\n        applyMotorVelocities(velocities);\r\n        mode.sleep(delayTimeMillis);\r\n    }\r\n\r\n    public void driveOnHeadingPID(double heading, double desiredVelocity, LinearOpMode mode) {\r\n        driveOnHeadingPID(heading, desiredVelocity, DEFAULT_DELAY_MILLIS, mode);\r\n    }\r\n\r\n    // Note: set turn Sp prior to calling\r\n    public void driveOnHeadingPID(double heading, double desiredVelocity, long delayTimeMillis, LinearOpMode mode) {\r\n        desiredVelocity = Math.abs(desiredVelocity);\r\n        double curOrientation = orientation.getOrientation();\r\n        double turnCorrection = turnController.calculatePID(curOrientation/*distanceFromSetPoint + headingController.getSp()*/); //issue with this line...\r\n        if (Double.isNaN(turnCorrection)) turnCorrection = 0;\r\n        Log.d(\"Delta Velocity:\", \"\" + turnCorrection);\r\n        double [] velocities = determineMotorVelocitiesToDriveOnHeading(heading, desiredVelocity);\r\n\r\n        Log.d(\"Initial Velocities:\", \"-----------\");\r\n        for(int i = 0; i < velocities.length; i++) {\r\n            Log.d(\"Motor \" + \" Velocity\", \"\" + velocities[i]);\r\n        }\r\n\r\n        double [] rotationalCorrections = calculateTurnVelocities(turnCorrection);\r\n        for(int i = 0; i < driveMotors.length; i++) {\r\n            velocities[i] += rotationalCorrections[i];\r\n        }\r\n//        if(heading > 315 || heading <= 45){\r\n//            Log.d(\"Wheels Affected\", \"-Left+Right\");\r\n//            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity; // 0\r\n//            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity; // 1\r\n//            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity; // 3\r\n//            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity; // 2\r\n//        }\r\n//\r\n//        else if(heading > 45 && heading <= 135){\r\n//            Log.d(\"Wheels Affected\", \"-Front+Back\");\r\n//            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity; // 0\r\n//            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity; // 1\r\n//            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity; // 3\r\n//            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity; // 2\r\n//        }\r\n//\r\n//        else if(heading > 135 && heading <= 225){\r\n//            Log.d(\"Wheels Affected\", \"-Right+Left\");\r\n//            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n//            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n//            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n//            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n//        }\r\n//\r\n//        else if(heading > 225 && heading <= 315){\r\n//            Log.d(\"Wheels Affected\", \"-Back+Front\");\r\n//            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n//            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n//            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] -= deltaVelocity;\r\n//            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] += deltaVelocity;\r\n//        }\r\n\r\n        Log.d(\"Final Velocities:\", \"-----------\");\r\n        for(int i = 0; i < velocities.length; i++) {\r\n            Log.d(\"Motor \" + \" Velocity\", \"\" + velocities[i]);\r\n        }\r\n\r\n        applyMotorVelocities(velocities);\r\n        mode.sleep(delayTimeMillis);\r\n    }\r\n\r\n    public void driveDistanceToLocation(Location target, double desiredVelocity, LinearOpMode mode) {\r\n        double heading = Math.toDegrees(Math.atan2(target.getY() - myLocation.getY(), target.getX() - myLocation.getX())) - 90;\r\n        heading = (360 - heading) - orientationOffset;\r\n        heading %= 360;\r\n        if(heading >= 360) heading -= 360;\r\n        if(heading < 0) heading += 360;\r\n        Log.d(\"Drive Distance Heading\", \"\"+heading);\r\n        driveDistance(myLocation.distanceToLocation(target), heading, desiredVelocity, mode);\r\n    }\r\n\r\n    public void driveDistance(double distanceInInches, double desiredVelocity, LinearOpMode mode) {\r\n        driveDistance(distanceInInches, myLocation.getHeading(), desiredVelocity, mode);\r\n    }\r\n\r\n    public void driveDistance(double distanceInInches, double heading, double desiredVelocity, LinearOpMode mode) {\r\n//        for(MotorController m : driveMotors) {\r\n//            m.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        }\r\n//        mode.idle();\r\n//        for(MotorController m : driveMotors) {\r\n//            m.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        }\r\n//        mode.idle();\r\n\r\n//        updateLastMotorPositionsInInches();\r\n\r\n        distanceInInches = Math.abs(distanceInInches);\r\n        double distanceTraveled = 0;\r\n        double [] motorPositionsInches = getMotorPositionsInches();\r\n        double [] startPositionsInches = motorPositionsInches;\r\n        double [] deltaInches;\r\n        double averagePosition = 0;\r\n        if (heading >= 360) heading -= 360;\r\n        else if (heading < 0) heading += 360;\r\n        double curOrientation = orientation.getOrientation();\r\n        turnController.setSp(curOrientation);\r\n        while (distanceTraveled < distanceInInches && mode.opModeIsActive()) {\r\n            //from our motor position, determine location\r\n            driveOnHeadingPID(heading,desiredVelocity,0, mode);\r\n            motorPositionsInches = getMotorPositionsInches();\r\n            deltaInches = new double[4];\r\n            averagePosition = 0;\r\n            if(heading == 45 || heading == 225) {\r\n                deltaInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n                deltaInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n                averagePosition += deltaInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] + deltaInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR];\r\n                averagePosition /= 2.0;\r\n                distanceTraveled = averagePosition;\r\n            } else if(heading == 135 || heading == 315) {\r\n                deltaInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n                deltaInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n                averagePosition += deltaInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] + deltaInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR];\r\n                averagePosition /= 2.0;\r\n                distanceTraveled = averagePosition;\r\n            } else {\r\n                for (int i = 0; i < motorPositionsInches.length; i++) {\r\n                    deltaInches[i] = Math.abs(motorPositionsInches[i] - startPositionsInches[i]);\r\n                }\r\n                for (double i : deltaInches) {\r\n                    averagePosition += i;\r\n                }\r\n                averagePosition /= (double) deltaInches.length;\r\n                distanceTraveled = averagePosition / Math.sin(Math.toRadians(45.0));\r\n            }\r\n            Log.d(\"Distance Travelled\", \"\" + distanceTraveled);\r\n        }\r\n        brake();\r\n        Log.d(\"Location\", getRobotLocation().toString());\r\n    }\r\n\r\n    public void driveDistanceAccelerationBased(double distanceInInches, double heading, double desiredVelocity, LinearOpMode mode) {\r\n        for(MotorController m : driveMotors) {\r\n            m.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        }\r\n        mode.idle();\r\n        for(MotorController m : driveMotors) {\r\n            m.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        }\r\n        distanceInInches = Math.abs(distanceInInches);\r\n        double distanceTraveled = 0;\r\n        double [] motorPositionsInches = getMotorPositionsInches();\r\n        double [] startPositionsInches = motorPositionsInches;\r\n        double [] deltaInches;\r\n        double averagePosition = 0;\r\n        double currVelocity = 0;\r\n        double accel = Math.pow(desiredVelocity, 2)/(2*distanceInInches);\r\n        if (heading >= 360) heading -= 360;\r\n        else if (heading < 0) heading += 360;\r\n        double curOrientation = orientation.getOrientation();\r\n        turnController.setSp(curOrientation);\r\n        double endTime = distanceInInches / desiredVelocity;\r\n        double startTime = System.currentTimeMillis() / 1000.0;\r\n        while (distanceTraveled < distanceInInches && mode.opModeIsActive()) {\r\n            double deltaTime = (System.currentTimeMillis() / 1000.0) - startTime;\r\n            //ACCELERATION CODE\r\n            if (deltaTime <= 0.5) {\r\n                currVelocity = desiredVelocity * deltaTime / 0.5;\r\n            } else if (distanceTraveled >= (2.0/3.0 * distanceInInches)) {\r\n                currVelocity = desiredVelocity * (1 - (distanceTraveled - (2.0/3.0) * distanceInInches) / (1.0/3.0 * distanceInInches));\r\n            } else {\r\n                currVelocity = desiredVelocity;\r\n            }\r\n            //from our motor position, determine location\r\n            driveOnHeadingPID(heading,currVelocity,0, mode);\r\n            motorPositionsInches = getMotorPositionsInches();\r\n            deltaInches = new double[4];\r\n            averagePosition = 0;\r\n            if(heading == 45 || heading == 225) {\r\n                deltaInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n                deltaInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n                averagePosition += deltaInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] + deltaInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR];\r\n                averagePosition /= 2.0;\r\n                distanceTraveled = averagePosition;\r\n            } else if(heading == 135 || heading == 315) {\r\n                deltaInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n                deltaInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n                averagePosition += deltaInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] + deltaInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR];\r\n                averagePosition /= 2.0;\r\n                distanceTraveled = averagePosition;\r\n            } else {\r\n                for (int i = 0; i < motorPositionsInches.length; i++) {\r\n                    deltaInches[i] = Math.abs(motorPositionsInches[i] - startPositionsInches[i]);\r\n                }\r\n                for (double i : deltaInches) {\r\n                    averagePosition += i;\r\n                }\r\n                averagePosition /= (double) deltaInches.length;\r\n                distanceTraveled = averagePosition / Math.sin(Math.toRadians(45.0));\r\n            }\r\n            Log.d(\"Distance Travelled\", \"\" + distanceTraveled);\r\n        }\r\n        brake();\r\n        Log.d(\"Location\", getRobotLocation().toString());\r\n    }\r\n\r\n    public void driveDistanceNonCorrected(double distanceInInches, double heading, double desiredVelocity, LinearOpMode mode) {\r\n        distanceInInches = Math.abs(distanceInInches);\r\n        double distanceTraveled = 0;\r\n        double [] motorPositionsInches = getMotorPositionsInches();\r\n        double [] startPositionsInches = motorPositionsInches;\r\n        double [] deltaInches;\r\n        double averagePosition = 0;\r\n        while(distanceTraveled < distanceInInches && mode.opModeIsActive()){\r\n            //from our motor position, determine location\r\n            driveOnHeading((int)(heading + .5),desiredVelocity);\r\n            motorPositionsInches = getMotorPositionsInches();\r\n            deltaInches = new double[4];\r\n            averagePosition = 0;\r\n            if(heading == 45 || heading == 225){\r\n                deltaInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n                deltaInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n                averagePosition += deltaInches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] + deltaInches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR];\r\n                averagePosition /= 2;\r\n                distanceTraveled = averagePosition;\r\n            } else if(heading == 135 || heading == 315){\r\n                deltaInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n                deltaInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(motorPositionsInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] - startPositionsInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n                averagePosition += deltaInches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] + deltaInches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR];\r\n                averagePosition /= 2;\r\n                distanceTraveled = averagePosition;\r\n            } else {\r\n                for (int i = 0; i < motorPositionsInches.length; i++) {\r\n                    deltaInches[i] = Math.abs(motorPositionsInches[i] - startPositionsInches[i]);\r\n                }\r\n                for (double i : deltaInches) {\r\n                    averagePosition += i;\r\n                }\r\n                averagePosition /= (double) deltaInches.length;\r\n                distanceTraveled = averagePosition / Math.sin(Math.toRadians(45));\r\n            }\r\n        }\r\n        brake();\r\n    }\r\n\r\n    long[] getMotorPositionsTicks(){\r\n        long[] positions = new long[4];\r\n        positions[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].getCurrentTick();\r\n        positions[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = driveMotors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR].getCurrentTick();\r\n        positions[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = driveMotors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR].getCurrentTick();\r\n        positions[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = driveMotors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR].getCurrentTick();\r\n        return  positions;\r\n    }\r\n\r\n    public double[] getMotorPositionsInches() {\r\n        double[] inches = new double [4];\r\n        long[] ticks = getMotorPositionsTicks();\r\n        inches[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].convertTicksToInches(ticks[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR]));\r\n        inches[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(driveMotors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR].convertTicksToInches(ticks[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR]));\r\n        inches[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(driveMotors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR].convertTicksToInches(ticks[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR]));\r\n        inches[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = Math.abs(driveMotors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR].convertTicksToInches(ticks[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR]));\r\n        return inches;\r\n    }\r\n\r\n    double[] determineMotorVelocitiesToDriveOnHeading(double heading, double desiredVelocity) {\r\n        double[] velocities = new double[4];\r\n        velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = desiredVelocity * Math.sin(Math.toRadians(heading + 45));\r\n        velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = desiredVelocity * Math.cos(Math.toRadians(heading + 45));\r\n        velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = desiredVelocity * Math.sin(Math.toRadians(heading + 45));\r\n        velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = desiredVelocity * Math.cos(Math.toRadians(heading + 45));\r\n        return velocities;\r\n    }\r\n\r\n    public void driveOnHeading(double heading, double desiredVelocity) {\r\n        applyMotorVelocities(determineMotorVelocitiesToDriveOnHeading(heading, desiredVelocity));\r\n    }\r\n\r\n    public void driveOnHeadingWithTurning(double heading, double movementPower, double turnPower){\r\n        double[] movementPowers = calculatePowersToDriveOnHeading(heading, movementPower);\r\n        double[] turningPowers = calculatePowersToTurn(turnPower);\r\n        double[] total = new double[4];\r\n\r\n        for (int i = 0; i < movementPowers.length; i ++)\r\n            total[i] = movementPowers[i] + turningPowers[i];\r\n\r\n        normalizePowers(total);\r\n        applyMotorPowers(total);\r\n    }\r\n\r\n    private double[] calculatePowersToDriveOnHeading(double heading, double desiredPower){\r\n        double[] powers = new double[4];\r\n        if(desiredPower == 0){\r\n            for(int i = 0; i < powers.length; i ++){\r\n                powers[i] = 0;\r\n            }\r\n            return powers;\r\n        }\r\n        powers[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = desiredPower * Math.sin(Math.toRadians(heading + 45));\r\n        powers[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = desiredPower * Math.cos(Math.toRadians(heading + 45));\r\n        powers[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = desiredPower * Math.sin(Math.toRadians(heading + 45));\r\n        powers[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = desiredPower * Math.cos(Math.toRadians(heading + 45));\r\n        //Log.d(\"MotorPow\",\"\" + powers[0]);\r\n        return powers;\r\n    }\r\n\r\n    private double[] calculatePowersToTurn(double desiredTurnRateOfMax) {\r\n        double[] powers = new double[] { 0, 0, 0, 0 };\r\n        if (desiredTurnRateOfMax == 0)\r\n            return powers;\r\n\r\n        powers[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = desiredTurnRateOfMax;\r\n        powers[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -desiredTurnRateOfMax;\r\n        powers[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = desiredTurnRateOfMax;\r\n        powers[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -desiredTurnRateOfMax;\r\n\r\n        for (int i = 0; i < powers.length; i++)\r\n            if (Double.isNaN(powers[i])) powers[i] = 0;\r\n\r\n        return powers;\r\n    }\r\n\r\n    private void normalizePowers(double[] toNormalize) {\r\n        //get the min and max powers\r\n        double min = toNormalize[0], max = toNormalize[0];\r\n        for (int i = 0; i < toNormalize.length; i++) {\r\n            if (toNormalize[i] < min) min = toNormalize[i];\r\n            else if (toNormalize[i] > max) max = toNormalize[i];\r\n        }\r\n        //assign toScaleAgainst to the largest (abs) value\r\n        double toScaleAgainst = 0;\r\n        if (Math.abs(min) < Math.abs(max)) toScaleAgainst = Math.abs(max);\r\n        else toScaleAgainst = Math.abs(min);\r\n        //if the largest (abs) is greater than 1, scale all values appropriately\r\n        if(toScaleAgainst > 1){\r\n            for(int i = 0; i < toNormalize.length; i ++){\r\n                toNormalize[i] = toNormalize[i] / toScaleAgainst;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void relativeDriveOnHeadingWithTurning(double heading, double driveVelocity, double magnitudeOfTurn) {\r\n        driveVelocity = Math.abs(driveVelocity);\r\n        double curOrientation = orientation.getOrientation();\r\n        double distanceFromHeading = 0;\r\n        distanceFromHeading = heading - curOrientation; // as in -1 if heading is 0 and current orientation is 1\r\n        if(distanceFromHeading > 180) distanceFromHeading -= 360;\r\n        if(distanceFromHeading < -180) distanceFromHeading += 360;\r\n        if(curOrientation > 315 || curOrientation <= 45){\r\n            headingController.setSp(0);\r\n        }\r\n        else if(curOrientation > 45 && curOrientation <= 135){\r\n            headingController.setSp(90);\r\n        }\r\n        else if(curOrientation > 135 && curOrientation <= 225){\r\n            headingController.setSp(180);\r\n        }\r\n        else if(curOrientation > 225 && curOrientation <= 315){\r\n            headingController.setSp(270);\r\n        }\r\n        double distanceFromSetPoint = headingController.getSp() - curOrientation;\r\n        if(distanceFromSetPoint < -180) distanceFromSetPoint += 360;\r\n        else if(distanceFromSetPoint > 180) distanceFromSetPoint -= 360;\r\n        if(distanceFromHeading < 0) distanceFromHeading += 360;\r\n        else if(distanceFromHeading > 360) distanceFromHeading -= 360;\r\n        double [] headingVelocities = determineMotorVelocitiesToDriveOnHeading(heading - curOrientation,driveVelocity);\r\n        //real quick, make distance from heading always positive\r\n        double [] turnVelocities =  calculateTurnVelocitiesRelativeToMax(magnitudeOfTurn);\r\n        double [] finalVelocities = new double[4];\r\n        for(int i = 0; i < finalVelocities.length; i ++){\r\n            finalVelocities[i] = turnVelocities[i] + headingVelocities[i];\r\n        }\r\n        //look for max and min values\r\n        double maxValue = finalVelocities[0];\r\n        double minValue = finalVelocities[0];\r\n        for(int i = 1; i < finalVelocities.length; i ++){\r\n            if(finalVelocities[i] > maxValue){\r\n                maxValue = finalVelocities[i];\r\n            }\r\n            else if(finalVelocities[i] < minValue){\r\n                minValue = finalVelocities[i];\r\n            }\r\n        }\r\n        //scale all motor powers to correspond withf maxVelocities\r\n        double scaleValue = 1;\r\n        if(Math.abs(maxValue) >= Math.abs(minValue)){\r\n            if(maxValue > driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].getMaxSpeed()){\r\n                scaleValue = driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].getMaxSpeed()/maxValue;\r\n            }\r\n        }\r\n        else if(Math.abs(maxValue) < Math.abs(minValue)){\r\n            if(Math.abs(minValue) > driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].getMaxSpeed()){\r\n                scaleValue = Math.abs(driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].getMaxSpeed()/ Math.abs(minValue));\r\n            }\r\n        }\r\n\r\n        if (scaleValue != 1) {\r\n            for(int i = 0; i < finalVelocities.length; i ++){\r\n                finalVelocities[i] *= scaleValue;\r\n                Log.d(\"final velocity\" + i,\"\" + finalVelocities[i]);\r\n            }\r\n        }\r\n\r\n        applyMotorVelocities(finalVelocities);\r\n    }\r\n\r\n    public double[] calculateTurnVelocitiesRelativeToMax(double percentOfMax){\r\n        double[] velocities = new double[4];\r\n        double maxWheelVelocity = driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].getMaxSpeed();\r\n        if (Double.isNaN(percentOfMax)) percentOfMax = 0;\r\n        double velocity = maxWheelVelocity * percentOfMax;\r\n        //double velocity = rps*WHEEL_BASE_RADIUS*2.0*Math.PI;\r\n\r\n        if (Double.isNaN(velocity))\r\n            return new double[] { 0, 0, 0, 0 };\r\n        else {\r\n            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = velocity;\r\n            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -velocity;\r\n            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = velocity;\r\n            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -velocity;\r\n        }\r\n        return velocities;\r\n    }\r\n\r\n    public double[] calculateTurnVelocities(double rps){\r\n        double[] velocities = new double[4];\r\n        if(Double.isNaN(rps)) rps = 0;\r\n        double velocity = rps*WHEEL_BASE_RADIUS*2.0* Math.PI;\r\n        if (Double.isNaN(velocity))\r\n            return new double[] { 0, 0, 0, 0 };\r\n        else {\r\n            velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = velocity;\r\n            velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -velocity;\r\n            velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = velocity;\r\n            velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -velocity;\r\n        }\r\n        return velocities;\r\n    }\r\n    public void turn(double rps) {\r\n        double[] velocities = calculateTurnVelocities(rps);\r\n        applyMotorVelocities(velocities);\r\n    }\r\n\r\n    public double getDistanceFromHeading(double targetAngle){\r\n        double distanceFromHeading = orientation.getOrientation() - targetAngle;\r\n        if(distanceFromHeading > 180) distanceFromHeading -= 360;\r\n        else if(distanceFromHeading < -180) distanceFromHeading += 360;\r\n        return distanceFromHeading;\r\n    }\r\n\r\n    public void turnToHeading(double desiredHeading, LinearOpMode mode) {\r\n        turnController.setSp(0);\r\n        double curHeading = orientation.getOrientation() % 360;\r\n        double rps;\r\n        double distanceFromHeading = 0;\r\n        distanceFromHeading = desiredHeading - curHeading;\r\n        if (distanceFromHeading > 180) distanceFromHeading -= 360;\r\n        else if (distanceFromHeading < -180) distanceFromHeading += 360;\r\n        if (distanceFromHeading >= 0 && distanceFromHeading <= 180) {\r\n            while (Math.abs(distanceFromHeading) > HEADING_THRESHOLD && mode.opModeIsActive()) {\r\n                //heading always positive\r\n                rps = turnController.calculatePID(distanceFromHeading);\r\n                turn(-rps);\r\n                mode.sleep(5);\r\n                curHeading = orientation.getOrientation();\r\n                distanceFromHeading = desiredHeading - curHeading;\r\n                if(distanceFromHeading > 180) distanceFromHeading = distanceFromHeading - 360;\r\n                else if(distanceFromHeading < -180) distanceFromHeading = 360 + distanceFromHeading;\r\n            }\r\n        }\r\n        else if ((distanceFromHeading <= 360 && distanceFromHeading >= 180) || distanceFromHeading < 0) {\r\n            while (Math.abs(distanceFromHeading) > HEADING_THRESHOLD && mode.opModeIsActive()) {\r\n                //heading always positive\r\n                rps = turnController.calculatePID(distanceFromHeading);\r\n                turn(-rps);\r\n                mode.sleep(5);\r\n                curHeading = orientation.getOrientation();\r\n                distanceFromHeading = desiredHeading - curHeading;\r\n                if(distanceFromHeading > 180) distanceFromHeading -= 360;\r\n                else if(distanceFromHeading < -180) distanceFromHeading += 360;\r\n            }\r\n        }\r\n        brake();\r\n    }\r\n\r\n    public void turnToHeading(double desiredHeading, double tolerance, LinearOpMode mode){\r\n        turnController.setSp(0);\r\n        double curHeading = orientation.getOrientation() % 360;\r\n        double rps;\r\n        double distanceFromHeading = 0;\r\n        distanceFromHeading = desiredHeading - curHeading;\r\n        if(distanceFromHeading > 180) distanceFromHeading = distanceFromHeading - 360;\r\n        else if(distanceFromHeading < -180) distanceFromHeading = 360 + distanceFromHeading;\r\n        if(distanceFromHeading >= 0 && distanceFromHeading <= 180){\r\n            while(Math.abs(distanceFromHeading) > tolerance && mode.opModeIsActive()){\r\n                //heading always positive\r\n                rps = turnController.calculatePID(distanceFromHeading);\r\n                turn(-rps);\r\n                mode.sleep(5);\r\n                curHeading = orientation.getOrientation();\r\n                distanceFromHeading = desiredHeading - curHeading;\r\n                if(distanceFromHeading > 180) distanceFromHeading = distanceFromHeading - 360;\r\n                else if(distanceFromHeading < -180) distanceFromHeading = 360 + distanceFromHeading;\r\n            }\r\n            brake();\r\n        }\r\n\r\n        else if((distanceFromHeading <= 360 && distanceFromHeading >= 180) || distanceFromHeading < 0){\r\n            while(Math.abs(distanceFromHeading) > tolerance && mode.opModeIsActive()){\r\n                //heading always positive\r\n                rps = turnController.calculatePID(distanceFromHeading);\r\n                turn(-rps);\r\n                mode.sleep(5);\r\n                curHeading = orientation.getOrientation();\r\n                distanceFromHeading = desiredHeading - curHeading;\r\n                if(distanceFromHeading > 180) distanceFromHeading = distanceFromHeading - 360;\r\n                else if(distanceFromHeading < -180) distanceFromHeading = 360 + distanceFromHeading;\r\n            }\r\n            brake();\r\n        }\r\n    }\r\n\r\n    public void setDrivePower(double power) { applyMotorPowers(new double[] { power, power, power, power }); }\r\n\r\n    public void turnToShoot(Location target, LinearOpMode mode) {\r\n        double dx = target.getX() - getRobotLocation().getX();\r\n        double dy = target.getY() - getRobotLocation().getY();\r\n        double angle = -77 - Math.toDegrees(Math.atan(-dy / Math.abs(dx)));\r\n        if (dx > 0)\r\n            angle *= -1;\r\n        turnToHeading(angle, mode);\r\n        mode.telemetry.addData(\"Angle to turn\", angle + \"\");\r\n    }\r\n\r\n    public void turnToLocation(Location target, LinearOpMode mode) {\r\n        double dx = target.getX() - myLocation.getX();\r\n        double dy = target.getY() - myLocation.getY();\r\n        double angle = -90 - Math.toDegrees(Math.atan(-dy / Math.abs(dx)));\r\n        if (dx > 0)\r\n            angle *= -1;\r\n        turnToHeading(angle, mode);\r\n//        mode.telemetry.addData(\"Angle to turn\", angle + \"\");\r\n    }\r\n\r\n    public void applyMotorVelocities(double[] velocities) {\r\n        for (MotorController motor : driveMotors)\r\n            motor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].setInchesPerSecondVelocity(velocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n        driveMotors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR].setInchesPerSecondVelocity(velocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n        driveMotors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR].setInchesPerSecondVelocity(velocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n        driveMotors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR].setInchesPerSecondVelocity(velocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n    }\r\n\r\n    public void applyMotorPowers(double[] powers) {\r\n        for (MotorController motor : driveMotors)\r\n            motor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        driveMotors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].setMotorPower(powers[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n        driveMotors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR].setMotorPower(powers[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n        driveMotors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR].setMotorPower(powers[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n        driveMotors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR].setMotorPower(powers[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n    }\r\n\r\n    public void brake() { applyMotorVelocities(new double [] { 0, 0, 0, 0 }); }\r\n\r\n    public void stopNavigation() {\r\n        shouldRun = false;\r\n        for (MotorController motor : driveMotors)\r\n            motor.killMotorController();\r\n        orientation.stopIMU();\r\n    }\r\n\r\n    private void driveToLocation(Location startLocation, Location targetLocation, double desiredSpeed, LinearOpMode mode){\r\n        double distanceToTravel = startLocation.distanceToLocation(targetLocation);\r\n        double prevDistance = 0;\r\n        double deltaX;\r\n        double deltaY;\r\n        double heading;\r\n        double startHeading = restrictAngle(orientation.getOrientation(), targetLocation.getHeading(), mode);\r\n        Log.d(\"Start heading\", startHeading + \"\");\r\n        double totalDistanceToTravel = distanceToTravel;\r\n        while(mode.opModeIsActive() && distanceToTravel > LOCATION_DISTANCE_TOLERANCE /*&& prevDistance - distanceToTravel < LOCATION_DISTANCE_TOLERANCE*4*/) {\r\n            prevDistance = distanceToTravel;\r\n            distanceToTravel = startLocation.distanceToLocation(targetLocation); // start location is updated from the robot's current location (myLocation)\r\n            Log.d(\"Distance to travel\", \"\" + distanceToTravel);\r\n            deltaX = targetLocation.getX() - startLocation.getX();\r\n            deltaY = targetLocation.getY() - startLocation.getY();\r\n            heading = Math.toDegrees(Math.atan2(deltaY, deltaX)) - 90;\r\n            heading = 360 - heading;\r\n            heading = (heading /*- orientation.getOrientation()*/) % 360;\r\n            if (heading >= 360) heading -= 360;\r\n            if (heading < 0) heading += 360;\r\n            Log.d(\"Drive Heading\", \"\"+heading);\r\n            double curOrientation = restrictAngle(orientation.getOrientation(), 180, mode);\r\n            Log.d(\"Robot Heading\", \"\"+curOrientation);\r\n            double fracOfDistance = distanceToTravel / (totalDistanceToTravel);\r\n            if(fracOfDistance > 1) fracOfDistance = 1;\r\n            turnController.setSp(/*(1-fracOfDistance)*(targetLocation.getHeading()) + (fracOfDistance)*(startHeading)*/targetLocation.getHeading());\r\n            correctedDriveOnHeadingIMU(heading /*- curOrientation*/, desiredSpeed, 10, mode);\r\n        }\r\n        brake();\r\n        Log.d(\"Location: \", \"REACHED!\");\r\n//        driveToLocation(startLocation, targetLocation, desiredSpeed, 10000, mode);\r\n    }\r\n\r\n    // TODO test this one, not the others\r\n    private void driveToLocationTest(Location startLocation, Location targetLocation, double desiredSpeed, LinearOpMode mode){\r\n        double distanceToTravel = startLocation.distanceToLocation(targetLocation);\r\n        double prevDistance = 0;\r\n        double deltaX;\r\n        double deltaY;\r\n        double heading;\r\n        double startHeading = restrictAngle(orientation.getOrientation(), targetLocation.getHeading(), mode);\r\n        Log.d(\"Start heading\", startHeading + \"\");\r\n        double totalDistanceToTravel = distanceToTravel;\r\n        while(mode.opModeIsActive() && distanceToTravel > LOCATION_DISTANCE_TOLERANCE /*&& prevDistance - distanceToTravel < LOCATION_DISTANCE_TOLERANCE*4*/) {\r\n            prevDistance = distanceToTravel;\r\n            distanceToTravel = startLocation.distanceToLocation(targetLocation); // start location is updated from the robot's current location (myLocation)\r\n            Log.d(\"Distance to travel\", \"\" + distanceToTravel);\r\n            deltaX = targetLocation.getX() - startLocation.getX();\r\n            deltaY = targetLocation.getY() - startLocation.getY();\r\n            heading = Math.toDegrees(Math.atan2(deltaY, deltaX)) - 90;\r\n            heading = 360 - heading;\r\n            heading = (heading /*- orientation.getOrientation()*/) % 360;\r\n            if (heading >= 360) heading -= 360;\r\n            if (heading < 0) heading += 360;\r\n            Log.d(\"Drive Heading\", \"\"+heading);\r\n            double curOrientation = restrictAngle(orientation.getOrientation(), 180, mode);\r\n            Log.d(\"Robot Heading\", \"\"+curOrientation);\r\n            double fracOfDistance = distanceToTravel / (totalDistanceToTravel);\r\n            if(fracOfDistance > 1) fracOfDistance = 1;\r\n            turnController.setSp(/*(1-fracOfDistance)*(targetLocation.getHeading()) + (fracOfDistance)*(startHeading)*/targetLocation.getHeading());\r\n            correctedDriveOnHeadingIMU(heading /*- curOrientation*/, desiredSpeed, 10, mode);\r\n        }\r\n        brake();\r\n        Log.d(\"Location: \", \"REACHED!\");\r\n//        driveToLocation(startLocation, targetLocation, desiredSpeed, 10000, mode);\r\n    }\r\n\r\n    private void driveToLocation(Location startLocation, Location targetLocation, double desiredSpeed, double secToQuit, LinearOpMode mode){\r\n        double distanceToTravel = startLocation.distanceToLocation(targetLocation);\r\n        double prevDistance = 0;\r\n        double deltaX;\r\n        double deltaY;\r\n        double heading;\r\n        double startHeading = restrictAngle(orientation.getOrientation(), targetLocation.getHeading(), mode);\r\n        Log.d(\"Start heading\", startHeading + \"\");\r\n        double totalDistanceToTravel = distanceToTravel;\r\n        long startTime = System.currentTimeMillis();\r\n        while(mode.opModeIsActive() && distanceToTravel > LOCATION_DISTANCE_TOLERANCE && System.currentTimeMillis() - startTime < secToQuit*1000) {\r\n            prevDistance = distanceToTravel;\r\n            distanceToTravel = startLocation.distanceToLocation(targetLocation); // start location is updated from the robot's current location (myLocation)\r\n            Log.d(\"Distance to travel\", \"\" + distanceToTravel);\r\n            deltaX = targetLocation.getX() - startLocation.getX();\r\n            deltaY = targetLocation.getY() - startLocation.getY();\r\n            heading = Math.toDegrees(Math.atan2(deltaY, deltaX)) - 90;\r\n            heading = 360 - heading;\r\n            heading = (heading - orientation.getOrientation()) % 360;\r\n            if (heading >= 360) heading -= 360;\r\n            if (heading < 0) heading += 360;\r\n            Log.d(\"Heading\", \"\"+heading);\r\n            double curOrientation = restrictAngle(orientation.getOrientation(), 180, mode);\r\n            double fracOfDistance = distanceToTravel / (totalDistanceToTravel);\r\n            if(fracOfDistance > 1) fracOfDistance = 1;\r\n            turnController.setSp(/*(1-fracOfDistance)*(targetLocation.getHeading()) + (fracOfDistance)*(startHeading)*/targetLocation.getHeading());\r\n            correctedDriveOnHeadingIMU(heading - curOrientation, desiredSpeed, 10, mode);\r\n        }\r\n        brake();\r\n    }\r\n\r\n    public void driveToLocationPID(Location startLocation, Location targetLocation, double desiredSpeed, double locationTolerance, LinearOpMode mode) {\r\n        xPositionController.setSp(0);\r\n        yPositionController.setSp(0);\r\n        turnController.setSp(0);\r\n\r\n        Location actualStartLocation = new Location(startLocation);\r\n        double turnGain = 60; // was 45\r\n        double decel = 50;\r\n        double accel = 80;\r\n        double xDist =  targetLocation.getX() - startLocation.getX();\r\n        double yDist = targetLocation.getY() - startLocation.getY();\r\n        double distToTravel = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\r\n        double distTravelled = 0;\r\n        double velocity = 0;\r\n        double distToHeading = targetLocation.getHeading() - startLocation.getHeading();\r\n        distToHeading = restrictAngle(distToHeading, 0, mode);\r\n        long startTime = System.currentTimeMillis();\r\n        while (mode.opModeIsActive() && (Math.abs(xDist) > locationTolerance || Math.abs(yDist) > locationTolerance || Math.abs(distToHeading) > HEADING_THRESHOLD)) {\r\n\r\n            xDist = targetLocation.getX() - startLocation.getX();\r\n            yDist = targetLocation.getY() - startLocation.getY();\r\n            distToHeading = targetLocation.getHeading() - startLocation.getHeading();\r\n            distToHeading = restrictAngle(distToHeading, 0, mode);\r\n            distTravelled = startLocation.distanceToLocation(actualStartLocation);\r\n\r\n//            This wasn't really logging and I got confused\r\n            Log.d(\"Xdist\", \"\" + xDist);\r\n            Log.d(\"Ydist\", \"\" + yDist);\r\n\r\n            double timeToStop = velocity / decel;\r\n            double distToStop = 0.5 * velocity * timeToStop;\r\n            distToStop += distToTravel * STOPPING_DISTANCE_FACTOR;\r\n            Log.d(\"Time to stop: \", \"\"+timeToStop);\r\n            Log.d(\"Dist to stop: \", \"\"+distToStop);\r\n            Log.d(\"Dist to travel: \", \"\"+distToTravel);\r\n            Log.d(\"Dist travelled: \", \"\"+distTravelled);\r\n            Log.d(\"Velocity: \", \"\"+velocity);\r\n            if (distTravelled >= distToTravel - distToStop) {\r\n                Log.d(\"Decelerating\", \"...\");\r\n                velocity = velocity - decel * (System.currentTimeMillis() - startTime) / 1000.0;\r\n                if(velocity > desiredSpeed) velocity = desiredSpeed;\r\n                if(velocity < 7.5) {\r\n                    velocity = 7.5; // limit to 15 to allow PID to take over\r\n                    Log.d(\"PID being used\", \"...\");\r\n                }\r\n            } else {\r\n                Log.d(\"Accelerating/Constant\", \"...\");\r\n                velocity = velocity + accel * (System.currentTimeMillis() - startTime) / 1000.0;\r\n                if(velocity > desiredSpeed) velocity = desiredSpeed;\r\n            }\r\n            startTime = System.currentTimeMillis();\r\n\r\n            double xCorrection = xPositionController.calculatePID(-xDist);\r\n            Log.d(\"xCorrection: \", xCorrection + \"\");\r\n            double yCorrection = yPositionController.calculatePID(-yDist);\r\n            Log.d(\"yCorrection: \", yCorrection + \"\");\r\n            double turnCorrection = turnController.calculatePID(-distToHeading) * turnGain;\r\n            Log.d(\"turnCorrection: \", turnCorrection + \"\");\r\n\r\n            double[] motorVelocities = new double[4];\r\n            if (startLocation.getHeading() <= 45 && startLocation.getHeading() > -45) { // 0\r\n                Log.d(\"dir\", \"0\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n\r\n            } else if (startLocation.getHeading() <= 135 && startLocation.getHeading() > 45) { // 90\r\n                Log.d(\"dir\", \"90\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n\r\n            } else if (startLocation.getHeading() <= -135 || startLocation.getHeading() > 135) { // 180 or -180\r\n                Log.d(\"dir\", \"180\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n\r\n            } else if (startLocation.getHeading() <= -45 && startLocation.getHeading() > -135) { // -90\r\n                Log.d(\"dir\", \"-90\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n\r\n            }\r\n            motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] += turnCorrection;\r\n            motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= turnCorrection;\r\n            motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= turnCorrection;\r\n            motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] += turnCorrection;\r\n\r\n            double maxValue = motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR], minValue = motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR];\r\n\r\n            for (double d : motorVelocities) {\r\n                if (maxValue < d) maxValue = d;\r\n                else if (minValue > d) minValue = d;\r\n            }\r\n\r\n            double toScaleBy = (Math.abs(maxValue) > Math.abs(minValue)) ? Math.abs(velocity / maxValue) : Math.abs(velocity / minValue);\r\n            for (int i = 0; i < motorVelocities.length; i++) motorVelocities[i] *= toScaleBy;\r\n//\r\n//            motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] += turnCorrection;\r\n//            motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= turnCorrection;\r\n//            motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= turnCorrection;\r\n//            motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] += turnCorrection;\r\n\r\n            applyMotorVelocities(motorVelocities);\r\n        }\r\n        brake();\r\n    }\r\n\r\n    public void driveToLocationPID(Location startLocation, Location targetLocation, double desiredSpeed, double locationTolerance, double secToQuit, LinearOpMode mode) {\r\n        xPositionController.setSp(0);\r\n        yPositionController.setSp(0);\r\n        turnController.setSp(0);\r\n\r\n        Location actualStartLocation = new Location(startLocation);\r\n        double turnGain = 60;\r\n        double decel = 32;\r\n        double accel = 40;\r\n        double xDist =  targetLocation.getX() - startLocation.getX();\r\n        double yDist = targetLocation.getY() - startLocation.getY();\r\n        double distToTravel = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\r\n        double distTravelled = 0;\r\n        double velocity = 0;\r\n        double distToHeading = targetLocation.getHeading() - startLocation.getHeading();\r\n        distToHeading = restrictAngle(distToHeading, 0, mode);\r\n        long startTime = System.currentTimeMillis(), loopStartTime = System.currentTimeMillis();\r\n        while (mode.opModeIsActive() && (Math.abs(xDist) > locationTolerance || Math.abs(yDist) > locationTolerance || Math.abs(distToHeading) > HEADING_THRESHOLD) && System.currentTimeMillis() - loopStartTime < secToQuit*1000) {\r\n            xDist = targetLocation.getX() - startLocation.getX();\r\n            yDist = targetLocation.getY() - startLocation.getY();\r\n            distToHeading = targetLocation.getHeading() - startLocation.getHeading();\r\n            distToHeading = restrictAngle(distToHeading, 0, mode);\r\n            distTravelled = startLocation.distanceToLocation(actualStartLocation);\r\n\r\n//            This wasn't really logging and I got confused\r\n            Log.d(\"Xdist\", \"\" + xDist);\r\n            Log.d(\"Ydist\", \"\" + yDist);\r\n\r\n            double timeToStop = velocity / decel;\r\n            double distToStop = 0.5 * velocity * timeToStop;\r\n            distToStop += distToTravel * STOPPING_DISTANCE_FACTOR;\r\n            Log.d(\"Time to stop: \", \"\"+timeToStop);\r\n            Log.d(\"Dist to stop: \", \"\"+distToStop);\r\n            Log.d(\"Dist to travel: \", \"\"+distToTravel);\r\n            Log.d(\"Dist travelled: \", \"\"+distTravelled);\r\n            Log.d(\"Velocity: \", \"\"+velocity);\r\n            if (distTravelled >= distToTravel - distToStop) {\r\n                Log.d(\"Decelerating\", \"...\");\r\n                velocity = velocity - decel * (System.currentTimeMillis() - startTime) / 1000.0;\r\n                if(velocity > desiredSpeed) velocity = desiredSpeed;\r\n                if(velocity < 7.5) {\r\n                    velocity = 7.5; // limit to 15 to allow PID to take over\r\n                    Log.d(\"PID being used\", \"...\");\r\n                }\r\n            } else {\r\n                Log.d(\"Accelerating/Constant\", \"...\");\r\n                velocity = velocity + accel * (System.currentTimeMillis() - startTime) / 1000.0;\r\n                if(velocity > desiredSpeed) velocity = desiredSpeed;\r\n            }\r\n            startTime = System.currentTimeMillis();\r\n\r\n            double xCorrection = xPositionController.calculatePID(-xDist);\r\n            Log.d(\"xCorrection: \", xCorrection + \"\");\r\n            double yCorrection = yPositionController.calculatePID(-yDist);\r\n            Log.d(\"yCorrection: \", yCorrection + \"\");\r\n            double turnCorrection = turnController.calculatePID(-distToHeading) * turnGain;\r\n            Log.d(\"turnCorrection: \", turnCorrection + \"\");\r\n\r\n            double[] motorVelocities = new double[4];\r\n            if(startLocation.getHeading() <= 45 && startLocation.getHeading() > -45) { // 0\r\n                Log.d(\"dir\", \"0\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n\r\n            } else if(startLocation.getHeading() <= 135 && startLocation.getHeading() > 45) { // 90\r\n                Log.d(\"dir\", \"90\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection + xCorrection;\r\n\r\n            } else if(startLocation.getHeading() <= -135 || startLocation.getHeading() > 135) { // 180 or -180\r\n                Log.d(\"dir\", \"180\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection + xCorrection;\r\n\r\n            } else if(startLocation.getHeading() <= -45 && startLocation.getHeading() > -135) { // -90\r\n                Log.d(\"dir\", \"-90\");\r\n                motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n                motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n                motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] = yCorrection - xCorrection;\r\n                motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] = -yCorrection - xCorrection;\r\n\r\n            }\r\n\r\n            double maxValue = motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR], minValue = motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR];\r\n\r\n            for (double d : motorVelocities) {\r\n                if (maxValue < d) maxValue = d;\r\n                else if (minValue > d) minValue = d;\r\n            }\r\n\r\n            double toScaleBy = (Math.abs(maxValue) > Math.abs(minValue)) ? Math.abs(velocity / maxValue) : Math.abs(velocity / minValue);\r\n            for (int i = 0; i < motorVelocities.length; i++) motorVelocities[i] *= toScaleBy;\r\n\r\n            motorVelocities[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR] += turnCorrection;\r\n            motorVelocities[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= turnCorrection;\r\n            motorVelocities[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR] -= turnCorrection;\r\n            motorVelocities[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR] += turnCorrection;\r\n\r\n            applyMotorVelocities(motorVelocities);\r\n        }\r\n        brake();\r\n    }\r\n\r\n    public void driveToLocationPID(Location startLocation, Location targetLocation, double desiredSpeed, LinearOpMode mode) {\r\n        driveToLocationPID(startLocation, targetLocation, desiredSpeed, LOCATION_DISTANCE_TOLERANCE, mode);\r\n    }\r\n\r\n    public void driveToLocationPID(Location targetLocation, double desiredSpeed, LinearOpMode mode) {\r\n        driveToLocationPID(myLocation, targetLocation, desiredSpeed, mode);\r\n    }\r\n\r\n    public void driveToLocationPID(Location targetLocation, double desiredSpeed, double locationTolerance, LinearOpMode mode) {\r\n        driveToLocationPID(myLocation, targetLocation, desiredSpeed, locationTolerance, mode);\r\n    }\r\n\r\n    public void driveToLocation(Location targetLocation, double desiredSpeed, LinearOpMode mode){\r\n        driveToLocation(myLocation, targetLocation, desiredSpeed, mode);\r\n    }\r\n\r\n    public void driveToLocation(Location targetLocation, double desiredSpeed, double secToQuit, LinearOpMode mode){\r\n        driveToLocation(myLocation, targetLocation, desiredSpeed, secToQuit, mode);\r\n    }\r\n\r\n    // TODO check this\r\n//    public void driveToLine(Line line, double desiredSpeed, LinearOpMode mode) {\r\n//        Location closestLocation = line.getClosestLocationOnLine(myLocation);\r\n//        driveToLocation(closestLocation, desiredSpeed, mode);\r\n//    }\r\n\r\n    public void driveToXY(Location location, double desiredSpeed, LinearOpMode mode) {\r\n        location.setHeading(orientation.getOrientation());\r\n        driveToLocationPID(location, desiredSpeed, mode);\r\n    }\r\n\r\n    public void navigatePath(Location[] paths, double desiredSpeed, LinearOpMode mode) {\r\n        for (Location path : paths) {\r\n            driveToLocation(path, desiredSpeed, mode);\r\n            Log.d(\"Target Location\", path + \"\");\r\n            Log.d(\"Actual Location\", getRobotLocation() + \"\");\r\n            mode.sleep(1000);\r\n        }\r\n    }\r\n\r\n    public void navigatePath(Location[] path, double desiredSpeed, double[] secToQuit, LinearOpMode mode) {\r\n        for (int i = 0; i < path.length; i++)\r\n            driveToLocation(path[i], desiredSpeed, secToQuit[i], mode);\r\n    }\r\n\r\n    public void navigatePathPID(Location[] path, double desiredSpeed, LinearOpMode mode) {\r\n        for (Location toTravelTo : path)\r\n            driveToLocationPID(toTravelTo, desiredSpeed, mode);\r\n    }\r\n\r\n    public HeadingVector[] getWheelVectors() {\r\n        double[] deltaWheelPositions = { 0, 0, 0, 0 };\r\n        for (int i = 0; i < driveMotors.length; i++) {\r\n            double a = driveMotors[i].getInchesFromStart();\r\n            Log.d(\"Last Motor Pos Inches:\", lastMotorPositionsInInches[i] + \"\");\r\n            deltaWheelPositions[i] = a - lastMotorPositionsInInches[i];\r\n            lastMotorPositionsInInches[i] = a;\r\n        }\r\n        //updateLastMotorPositionsInInches();\r\n        HeadingVector[] vectors = new HeadingVector[4];\r\n        for (int i = 0; i < vectors.length; i++)\r\n            vectors[i] = new HeadingVector();\r\n\r\n        vectors[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR].calculateVector(FL_WHEEL_HEADING_OFFSET, deltaWheelPositions[FRONT_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n        vectors[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR].calculateVector(FR_WHEEL_HEADING_OFFSET, deltaWheelPositions[FRONT_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n        vectors[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR].calculateVector(BL_WHEEL_HEADING_OFFSET, deltaWheelPositions[BACK_LEFT_HOLONOMIC_DRIVE_MOTOR]);\r\n        vectors[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR].calculateVector(BR_WHEEL_HEADING_OFFSET, deltaWheelPositions[BACK_RIGHT_HOLONOMIC_DRIVE_MOTOR]);\r\n        return vectors;\r\n    }\r\n\r\n    private double restrictAngle(double angleToChange, double referenceAngle, LinearOpMode mode) {\r\n        while (mode.opModeIsActive() && angleToChange < referenceAngle - 180) angleToChange += 360;\r\n        while (mode.opModeIsActive() && angleToChange > referenceAngle + 180) angleToChange -= 360;\r\n        return angleToChange;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/DriveEngine/Ultimate/UltimateNavigation.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/DriveEngine/Ultimate/UltimateNavigation.java	(date 1608581092595)
@@ -324,14 +324,14 @@
         startTime = System.nanoTime();
     }
 
-//    public void setLocation(Location loc) { myLocation = new Location(loc.getX(), loc.getY()); }
+    public void setLocation(Location loc) { myLocation = new Location(loc.getX(), loc.getY()); }
 
     private void updateData() {
 
         getRobotHeading();
         wheelVectors = getWheelVectors();
         updateLocation();
-        updateIMUTrackedDistance();
+//        updateIMUTrackedDistance();
     }
 
     private void safetySleep(long time){
Index: TeamCode/src/main/java/Autonomous/OpModes/Tests/VuforiaImageCaptureTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Autonomous.OpModes.Tests;\r\n\r\nimport android.graphics.Bitmap;\r\nimport android.util.Log;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\n\r\nimport java.util.ArrayList;\r\n\r\nimport Autonomous.ImageProcessing.CryptoBoxColumnImageProcessor;\r\nimport Autonomous.VuforiaHelper;\r\n\r\n/**\r\n * Created by root on 11/20/17.\r\n */\r\n\r\n/*\r\n    An opmode to test saving images using vuforia\r\n */\r\n@Autonomous(name=\"Save Image Test\", group=\"Testers\")  // @Autonomous(...) is the other common choice\r\n@Disabled\r\npublic class VuforiaImageCaptureTest extends LinearOpMode {\r\n\r\n    CryptoBoxColumnImageProcessor cryptoFinder;\r\n    @Override\r\n    public void runOpMode() throws InterruptedException {\r\n        int imageTaken = 0;\r\n        CryptoBoxColumnImageProcessor.CRYPTOBOX_COLOR color = CryptoBoxColumnImageProcessor.CRYPTOBOX_COLOR.BLUE;\r\n        /*To access the image: you need to iterate through the images of the frame object:*/\r\n        VuforiaHelper vuforia = new VuforiaHelper(hardwareMap);\r\n        //wait for the op mode to start, this is the time to change teams\r\n        while (!opModeIsActive()) {\r\n            if (gamepad1.start) {\r\n                if(color == CryptoBoxColumnImageProcessor.CRYPTOBOX_COLOR.BLUE) color = CryptoBoxColumnImageProcessor.CRYPTOBOX_COLOR.RED;\r\n                else color = CryptoBoxColumnImageProcessor.CRYPTOBOX_COLOR.BLUE;\r\n                while (gamepad1.start) ;\r\n            }\r\n            telemetry.addData(\"Color\", color);\r\n            telemetry.update();\r\n        }\r\n        //initialize the image processor \r\n        cryptoFinder = new CryptoBoxColumnImageProcessor(CryptoBoxColumnImageProcessor.DESIRED_HEIGHT, CryptoBoxColumnImageProcessor.DESIRED_WIDTH,.1,1, color);\r\n        telemetry.addData(\"Status\",\"Initialized\");\r\n\r\n        waitForStart();\r\n        //storage variables \r\n        Bitmap bmp;\r\n        ArrayList<Integer> columnLocations = new ArrayList<Integer>();\r\n        while(opModeIsActive()){\r\n            long timeStart = System.currentTimeMillis();\r\n            //get an image \r\n            bmp = vuforia.getImage(CryptoBoxColumnImageProcessor.DESIRED_WIDTH, CryptoBoxColumnImageProcessor.DESIRED_HEIGHT);\r\n            if(bmp != null){\r\n                long algorithmStart = System.currentTimeMillis();\r\n                //find the columns \r\n                columnLocations = cryptoFinder.findColumns(bmp,true);\r\n                telemetry.addData(\"Algorithm Time\", \"\" + (System.currentTimeMillis() - algorithmStart));\r\n                //for every column seen, print its location \r\n                if(columnLocations != null){\r\n                    for(int i = 0; i < columnLocations.size(); i ++){\r\n                        telemetry.addData(\"Column \" + i, \" \" + columnLocations.get(i).intValue());\r\n                    }\r\n                }\r\n                //save every tenth image \r\n                if(imageTaken == 50) {\r\n                    vuforia.saveBMP(bmp); // save edited image\r\n                    imageTaken = 0; \r\n                }\r\n                imageTaken++;\r\n                telemetry.addData(\"Loop Time\", \"\" + (System.currentTimeMillis() - timeStart));\r\n                telemetry.update();\r\n            }\r\n            else{\r\n                Log.d(\"BMP\",\"NULL!\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/Autonomous/OpModes/Tests/VuforiaImageCaptureTest.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/Autonomous/OpModes/Tests/VuforiaImageCaptureTest.java	(date 1608578792814)
@@ -19,7 +19,7 @@
 /*
     An opmode to test saving images using vuforia
  */
-@Autonomous(name="Save Image Test", group="Testers")  // @Autonomous(...) is the other common choice
+@Autonomous(name="Capture Test", group="Testers")  // @Autonomous(...) is the other common choice
 @Disabled
 public class VuforiaImageCaptureTest extends LinearOpMode {
 
Index: TeamCode/src/main/java/UserControlled/VuforiaTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage UserControlled;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\n\r\nimport Autonomous.ColorDetector;\r\nimport Autonomous.VuforiaHelper;\r\n\r\n@TeleOp(name=\"Vuforia Test\", group=\"Testers\")\r\n//@Disabled\r\npublic class VuforiaTest extends LinearOpMode {\r\n    // create objects and locally global variables here\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        // initialize objects and variables here\r\n        // also create and initialize function local variables here\r\n        VuforiaHelper vuforia = new VuforiaHelper(hardwareMap);\r\n        ColorDetector ringDetector = ColorDetector.ringDetector(vuforia);\r\n        GamepadController controller = new GamepadController(gamepad1);\r\n\r\n        // add any other useful telemetry data or logging data here\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.update();\r\n        // nothing goes between the above and below lines\r\n        waitForStart();\r\n        // should only be used for a time keeper or other small things, avoid using this space when possible\r\n        while (opModeIsActive()) {\r\n            // main code goes here\r\n            telemetry.addData(\"Orange pixels\", \"\" + ringDetector.findNumDesiredPixels());\r\n            telemetry.addData(\"R\", \"\" + ringDetector.targetR);\r\n            telemetry.addData(\"G\", \"\" + ringDetector.targetG);\r\n            telemetry.addData(\"B\", \"\" + ringDetector.targetB);\r\n            telemetry.addData(\"Tolerance\", \"\" + ringDetector.tolerance);\r\n            telemetry.addData(\"Num Rings\", \"\" + ringDetector.getNumRingsFound(1));\r\n\r\n            controller.update(gamepad1);\r\n\r\n            if (controller.aHeld()) ringDetector.targetR++;\r\n            if (controller.bHeld()) ringDetector.targetR--;\r\n            if (controller.dpadUpHeld()) ringDetector.targetG++;\r\n            if (controller.dpadDownHeld()) ringDetector.targetG--;\r\n            if (controller.leftBumperHeld()) ringDetector.targetB++;\r\n            if (controller.rightBumperHeld()) ringDetector.targetB--;\r\n            if (controller.xHeld()) ringDetector.tolerance++;\r\n            if (controller.yHeld()) ringDetector.tolerance--;\r\n\r\n            telemetry.update();\r\n        }\r\n        // disable/kill/stop objects here\r\n    }\r\n    // misc functions here\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/VuforiaTest.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/UserControlled/VuforiaTest.java	(date 1608578830799)
@@ -63,7 +63,7 @@
             telemetry.addData("Tolerance", "" + ringDetector.tolerance);
             telemetry.addData("Num Rings", "" + ringDetector.getNumRingsFound(1));
 
-            controller.update(gamepad1);
+            controller.update();
 
             if (controller.aHeld()) ringDetector.targetR++;
             if (controller.bHeld()) ringDetector.targetR--;
Index: TeamCode/src/main/java/UserControlled/Ultimate/UltimateV1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage UserControlled.Ultimate;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\n\r\nimport Actions.Ultimate.RingIntakeSystemV1;\r\nimport Actions.Ultimate.ShooterSystemV1;\r\nimport Actions.Ultimate.WobbleGrabberV1;\r\nimport Autonomous.ConfigVariables;\r\nimport Autonomous.Location;\r\nimport DriveEngine.Ultimate.UltimateNavigation;\r\nimport UserControlled.GamepadController;\r\nimport UserControlled.JoystickHandler;\r\n\r\n/**\r\n * Author: Software Team 2020-2021\r\n *\r\n * Controls the Ultimate Goal Robot\r\n *\r\n * -------------- TLDR ---------------\r\n * Player One:\r\n *      joysticks - drive base\r\n *      start - slow mode\r\n *      a - shoot\r\n *      b - aim to right power shot\r\n *      x - aim to left power shot\r\n *      y - aim to middle power shot\r\n *      dpad up / down - raise / lower shooter angle\r\n *      dpad left / right - bring shooter all the way down / up\r\n *      right bumper - raise elevator\r\n *      left bumper - lower elevator\r\n *      right trigger - aim to top goal\r\n *\r\n * Player Two:\r\n *      b - intake direction\r\n *      a - intake power\r\n *      dpad up / down - raise / lower wobble grabber arm\r\n *      x - resets arm position for grabbing wobble goal\r\n *      y - grabbing or releasing wobble goal\r\n *      dpad up and down - raise and lower wobble grabber arm\r\n */\r\n\r\n@TeleOp(name=\"Ultimate V1\", group=\"Competition\")\r\n//@Disabled\r\npublic class UltimateV1 extends LinearOpMode {\r\n\r\n    // TODO add speed values and angles when using the wobble grabber\r\n\r\n    // create objects and locally global variables here\r\n    UltimateNavigation robot;\r\n    JoystickHandler leftStick, rightStick;\r\n    GamepadController controllerOne, controllerTwo;\r\n\r\n    RingIntakeSystemV1 intake;\r\n    ShooterSystemV1 shooter;\r\n    WobbleGrabberV1 grabber;\r\n\r\n    boolean eStop = false, slowMode = false;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        // initialize objects and variables here\r\n        // also create and initialize function local variables here\r\n\r\n        // initialize robot\r\n        // TODO get starting angle\r\n        try {\r\n            robot = new UltimateNavigation(hardwareMap, new Location(0, 0, 0), \"RobotConfig/UltimateV1.json\");\r\n        } catch (Exception e) {\r\n            telemetry.addData(\"Robot Error\", e.toString());\r\n            telemetry.update();\r\n        }\r\n\r\n        // initialize systems\r\n        intake = new RingIntakeSystemV1(hardwareMap);\r\n        shooter = new ShooterSystemV1(hardwareMap, this);\r\n        grabber = new WobbleGrabberV1(hardwareMap);\r\n\r\n        // initialize joysticks\r\n        leftStick = new JoystickHandler(gamepad1, JoystickHandler.LEFT_JOYSTICK);\r\n        rightStick = new JoystickHandler(gamepad1, JoystickHandler.RIGHT_JOYSTICK);\r\n\r\n        // initialize controllers\r\n        controllerOne = new GamepadController(gamepad1);\r\n        controllerTwo = new GamepadController(gamepad2);\r\n\r\n        // add any other useful telemetry data or logging data here\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.update();\r\n\r\n        // nothing goes between the above and below lines\r\n\r\n        waitForStart();\r\n\r\n        // puts the pinball servo on the outside\r\n        shooter.pinballServo.setPosition(ShooterSystemV1.PINBALL_REST);\r\n\r\n        // should only be used for a time keeper or other small things, avoid using this space when possible\r\n        while (opModeIsActive()) {\r\n            // main code goes here\r\n//            telemetry.addData(\"Shooter angle: \", \"\" + shooter.aimServo.getPosition());\r\n//            telemetry.update();\r\n\r\n            updateEStop();\r\n            if (!eStop) {\r\n\r\n                // start button controls slow mode\r\n                if (controllerOne.startPressed())\r\n                    slowMode = !slowMode;\r\n\r\n                updateEStop();\r\n\r\n                controlDrive();\r\n\r\n                updateEStop();\r\n\r\n                if (!eStop) {\r\n                    controllerOne.update(gamepad1);\r\n                    controllerTwo.update(gamepad2);\r\n\r\n                    playerOneFunctions(controllerOne);\r\n                    playerTwoFunctions(controllerTwo);\r\n                }\r\n            }\r\n\r\n            if (eStop)\r\n                stopActions();\r\n\r\n            // telemetry and logging data goes here\r\n            telemetry.update();\r\n        }\r\n\r\n        // disable/kill/stop objects here\r\n        robot.stopNavigation();\r\n    }\r\n\r\n    // misc functions here\r\n    private void updateEStop() {\r\n        if ((controllerOne.dpadDownHeld() && gamepad1.back) || (controllerTwo.dpadDownHeld() && gamepad2.back))\r\n            eStop = !eStop;\r\n    }\r\n\r\n    private void controlDrive() {\r\n        double drivePower = slowMode ? leftStick.magnitude() / 3 : leftStick.magnitude();\r\n        double turnPower = slowMode ? rightStick.x() / 4 : rightStick.x();\r\n        if (!eStop)\r\n            robot.driveOnHeadingWithTurning(leftStick.angle(), drivePower, turnPower);\r\n    }\r\n\r\n    private void playerOneFunctions(GamepadController controller) {\r\n\r\n        if (controller.aPressed())\r\n            shooter.shoot();\r\n\r\n        if (controllerOne.bPressed())\r\n            shooter.keepElevatorAtTop();\r\n\r\n        if (controllerOne.xPressed())\r\n            shooter.setShooter(ShooterSystemV1.HIGHEST_POSITION);\r\n\r\n        if (controller.dpadUpPressed())\r\n            robot.turnToShoot(ConfigVariables.TOP_GOAL, this);  // set angle to aim at the top goal\r\n\r\n        if (controller.dpadDownPressed())\r\n            robot.turnToShoot(ConfigVariables.POWER_SHOT_MIDDLE, this); // set angle to center power shot\r\n\r\n        if (controller.dpadLeftPressed())\r\n            robot.turnToShoot(ConfigVariables.POWER_SHOT_LEFT, this); // set angle to left power shot\r\n\r\n        if (controller.dpadRightPressed())\r\n            robot.turnToShoot(ConfigVariables.POWER_SHOT_RIGHT, this); // set angle to right power shot\r\n\r\n        if (controllerOne.leftBumperPressed())\r\n            shooter.lowerElevator();\r\n    }\r\n\r\n    private void playerTwoFunctions(GamepadController controller) {\r\n\r\n        if (controller.xPressed())\r\n            shooter.toggleWheelPower();\r\n\r\n        if (controller.yPressed())\r\n            grabber.grabOrReleaseWobbleGoal();\r\n\r\n        if (controller.dpadUpPressed())\r\n            grabber.increaseAngle();\r\n\r\n        if (controller.dpadDownPressed())\r\n            grabber.decreaseAngle();\r\n\r\n        if (controller.bPressed())\r\n            intake.toggleIntake();\r\n\r\n        if (controller.aPressed())\r\n            intake.toggleOuttake();\r\n\r\n        if (controller.startPressed())\r\n            grabber.raiseToVertical();\r\n\r\n        if (controller.rightBumperPressed())\r\n            shooter.keepElevatorAtTop();\r\n\r\n        if (controller.leftBumperPressed())\r\n            shooter.lowerElevator();\r\n    }\r\n\r\n    private void stopActions() {\r\n        robot.brake();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/Ultimate/UltimateV1.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/UserControlled/Ultimate/UltimateV1.java	(date 1608578825094)
@@ -144,8 +144,8 @@
                 updateEStop();
 
                 if (!eStop) {
-                    controllerOne.update(gamepad1);
-                    controllerTwo.update(gamepad2);
+                    controllerOne.update();
+                    controllerTwo.update();
 
                     playerOneFunctions(controllerOne);
                     playerTwoFunctions(controllerTwo);
Index: TeamCode/src/main/java/Actions/Ultimate/ShooterSystemV1Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Actions.Ultimate;\r\n\r\nimport android.util.Log;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\n\r\nimport java.io.IOException;\r\n\r\nimport Actions.HardwareWrappers.ServoHandler;\r\nimport Autonomous.ConfigVariables;\r\nimport MotorControllers.MotorController;\r\nimport SensorHandlers.MagneticLimitSwitch;\r\n\r\n/**\r\n * Author: Ethan Fisher\r\n * Date: 10/21/2020\r\n *\r\n * Used for shooting rings\r\n */\r\npublic class ShooterSystemV1Test {\r\n\r\n    public ServoHandler aimServo;\r\n    public static final double HIGHEST_POSITION = 0;\r\n    public static final double POWER_SHOT_POSITION = 0.45;\r\n    public static final double LOWERED_POSITION = 1;\r\n    final double ANGLE_INCREMENT = 0.05;\r\n\r\n    // good\r\n    public MotorController wheelMotor;\r\n    private boolean wheelSpinning;\r\n    private static final int SHOOTER_ON_SPEED = 418; // inches per second\r\n\r\n    // good\r\n    public ServoHandler elevatorServo;\r\n    public static final int TOP = 2;\r\n    public static final int MIDDLE = 1;\r\n    public static final int BOTTOM = 0;\r\n    public int elevatorPosition;\r\n    public boolean stayAtTop;\r\n    public volatile MagneticLimitSwitch elevatorTopSwitch;\r\n    public volatile MagneticLimitSwitch elevatorBottomSwitch;\r\n\r\n    // good\r\n    public Servo pinballServo;\r\n    private double pinballAngle;\r\n    public static final double PINBALL_TURNED = 1;\r\n    public static final double PINBALL_REST = 0;\r\n\r\n    public ShooterSystemV1Test(HardwareMap hardwareMap, final LinearOpMode mode) {\r\n        aimServo = new ServoHandler(\"aimServo\", hardwareMap);\r\n        try {\r\n            wheelMotor = new MotorController(\"wheelMotor\", \"MotorConfig/NoLoad40.json\", hardwareMap);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        elevatorServo = new ServoHandler(\"elevatorServo\", hardwareMap);\r\n        elevatorTopSwitch = new MagneticLimitSwitch(hardwareMap.digitalChannel.get(\"elevatorTopSwitch\"));\r\n        elevatorBottomSwitch = new MagneticLimitSwitch(hardwareMap.digitalChannel.get(\"elevatorBottomSwitch\"));\r\n\r\n        pinballServo = hardwareMap.servo.get(\"pinballServo\");\r\n\r\n        wheelSpinning = false;\r\n        elevatorPosition = BOTTOM;\r\n        pinballAngle = PINBALL_REST;\r\n        stayAtTop = false;\r\n    }\r\n\r\n    public void toggleWheelPower() {\r\n        wheelSpinning = !wheelSpinning;\r\n        wheelMotor.setInchesPerSecondVelocity(wheelSpinning ? SHOOTER_ON_SPEED : 0);\r\n    }\r\n\r\n    public void turnOnShooterWheel() {\r\n        wheelSpinning = true;\r\n        wheelMotor.setInchesPerSecondVelocity(SHOOTER_ON_SPEED);\r\n    }\r\n\r\n    public void turnOffShooterWheel() {\r\n        wheelSpinning = false;\r\n        wheelMotor.brake();\r\n    }\r\n\r\n    // moves the pinball servo\r\n    public void shoot() {\r\n        if (pinballAngle == PINBALL_TURNED)\r\n            pinballAngle = PINBALL_REST;\r\n        else\r\n            pinballAngle = PINBALL_TURNED;\r\n\r\n        pinballServo.setPosition(pinballAngle);\r\n    }\r\n\r\n    public void raiseShooter() {\r\n        aimServo.setPosition(aimServo.getPosition() - ANGLE_INCREMENT);\r\n    }\r\n\r\n    public void lowerShooter() {\r\n        aimServo.setPosition(aimServo.getPosition() + ANGLE_INCREMENT);\r\n    }\r\n\r\n    public void setShooter(double angle) { aimServo.setPosition(angle); }\r\n\r\n    public void raiseElevator() {\r\n        if (elevatorPosition != TOP)\r\n            elevatorServo.setPosition(0);\r\n    }\r\n\r\n    public void lowerElevator() {\r\n        stayAtTop = false;\r\n        if (elevatorPosition != BOTTOM)\r\n            elevatorServo.setPosition(1);\r\n    }\r\n\r\n    public void keepElevatorAtTop() {\r\n        stayAtTop = true;\r\n        raiseElevator();\r\n    }\r\n\r\n    public void stopElevator() { elevatorServo.setPosition(0.5); }\r\n\r\n    public void update() {\r\n        if (elevatorTopSwitch.isActivated() && elevatorPosition != TOP) {\r\n            elevatorPosition = TOP;\r\n            elevatorServo.setPosition(0.5);\r\n        } else if (elevatorBottomSwitch.isActivated() && !stayAtTop) { //watch out for the zero case because then the robot will think its at the bottom when its at the top\r\n            elevatorPosition = BOTTOM;\r\n            elevatorServo.setPosition(0.5);\r\n        } else if (!elevatorTopSwitch.isActivated() && stayAtTop)\r\n            elevatorServo.setPosition(0);\r\n\r\n        if (!elevatorTopSwitch.isActivated() && !elevatorBottomSwitch.isActivated())\r\n            elevatorPosition = MIDDLE;\r\n    }\r\n\r\n    public double calculateRingVelocity(double xDistance, double yDistance) {\r\n        double temp0 = yDistance - xDistance * Math.tan(ConfigVariables.SHOOTER_ANGLE);\r\n        if (temp0 < 0)\r\n            return 0;\r\n        double temp1 = Math.sqrt(-4.9 * xDistance * temp0);\r\n        return Math.cos(ConfigVariables.SHOOTER_ANGLE) / temp1;\r\n    }\r\n}\r\n
===================================================================
--- TeamCode/src/main/java/Actions/Ultimate/ShooterSystemV1Test.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/Actions/Ultimate/ShooterSystemV2Test.java	(date 1608578705737)
@@ -3,23 +3,26 @@
 import android.util.Log;
 
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.hardware.DcMotorSimple;
 import com.qualcomm.robotcore.hardware.HardwareMap;
 import com.qualcomm.robotcore.hardware.Servo;
 
 import java.io.IOException;
 
+import Actions.ActionHandler;
 import Actions.HardwareWrappers.ServoHandler;
 import Autonomous.ConfigVariables;
 import MotorControllers.MotorController;
 import SensorHandlers.MagneticLimitSwitch;
 
 /**
- * Author: Ethan Fisher
- * Date: 10/21/2020
+ * Author: Jordan Martin
+ * Date: 12/19/2020
  *
  * Used for shooting rings
  */
-public class ShooterSystemV1Test {
+public class ShooterSystemV2Test implements ActionHandler {
 
     public ServoHandler aimServo;
     public static final double HIGHEST_POSITION = 0;
@@ -43,23 +46,30 @@
     public volatile MagneticLimitSwitch elevatorBottomSwitch;
 
     // good
-    public Servo pinballServo;
+    public ServoHandler pinballServo;
     private double pinballAngle;
     public static final double PINBALL_TURNED = 1;
     public static final double PINBALL_REST = 0;
 
-    public ShooterSystemV1Test(HardwareMap hardwareMap, final LinearOpMode mode) {
+    public ShooterSystemV2Test(HardwareMap hardwareMap) {
         aimServo = new ServoHandler("aimServo", hardwareMap);
+        aimServo.setDirection(Servo.Direction.FORWARD);
+
         try {
             wheelMotor = new MotorController("wheelMotor", "MotorConfig/NoLoad40.json", hardwareMap);
+            wheelMotor.setDirection(DcMotorSimple.Direction.FORWARD);
+            wheelMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
+            wheelMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
         } catch (IOException e) {
             e.printStackTrace();
         }
         elevatorServo = new ServoHandler("elevatorServo", hardwareMap);
+        elevatorServo.setDirection(Servo.Direction.FORWARD);
         elevatorTopSwitch = new MagneticLimitSwitch(hardwareMap.digitalChannel.get("elevatorTopSwitch"));
         elevatorBottomSwitch = new MagneticLimitSwitch(hardwareMap.digitalChannel.get("elevatorBottomSwitch"));
 
-        pinballServo = hardwareMap.servo.get("pinballServo");
+        pinballServo = new ServoHandler("pinballServo", hardwareMap);
+        pinballServo.setDirection(Servo.Direction.FORWARD);
 
         wheelSpinning = false;
         elevatorPosition = BOTTOM;
@@ -67,18 +77,11 @@
         stayAtTop = false;
     }
 
-    public void toggleWheelPower() {
-        wheelSpinning = !wheelSpinning;
-        wheelMotor.setInchesPerSecondVelocity(wheelSpinning ? SHOOTER_ON_SPEED : 0);
-    }
-
     public void turnOnShooterWheel() {
-        wheelSpinning = true;
         wheelMotor.setInchesPerSecondVelocity(SHOOTER_ON_SPEED);
     }
 
     public void turnOffShooterWheel() {
-        wheelSpinning = false;
         wheelMotor.brake();
     }
 
@@ -92,14 +95,6 @@
         pinballServo.setPosition(pinballAngle);
     }
 
-    public void raiseShooter() {
-        aimServo.setPosition(aimServo.getPosition() - ANGLE_INCREMENT);
-    }
-
-    public void lowerShooter() {
-        aimServo.setPosition(aimServo.getPosition() + ANGLE_INCREMENT);
-    }
-
     public void setShooter(double angle) { aimServo.setPosition(angle); }
 
     public void raiseElevator() {
@@ -141,4 +136,24 @@
         double temp1 = Math.sqrt(-4.9 * xDistance * temp0);
         return Math.cos(ConfigVariables.SHOOTER_ANGLE) / temp1;
     }
+
+    @Override
+    public boolean doAction(String action, long maxTimeAllowed) {
+        return false;
+    }
+
+    @Override
+    public boolean stopAction(String action) {
+        return false;
+    }
+
+    @Override
+    public boolean startDoingAction(String action) {
+        return false;
+    }
+
+    @Override
+    public void kill() {
+        wheelMotor.killMotorController();
+    }
 }
Index: TeamCode/src/main/java/Actions/RingIntakeSystemV1.java
===================================================================
--- TeamCode/src/main/java/Actions/RingIntakeSystemV1.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/Actions/RingIntakeSystemV1.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
@@ -1,16 +0,0 @@
-package Actions;
-
-import com.qualcomm.robotcore.hardware.HardwareMap;
-
-public class RingIntakeSystemV1 {
-
-    public RingIntakeSystemV1(HardwareMap hardwareMap) {
-    }
-
-    public void toggleIntakePower() {
-    }
-
-    public void toggleIntakeDirection() {
-    }
-
-}
Index: TeamCode/src/main/java/Actions/Ultimate/WobbleGrabberV2Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/Actions/Ultimate/WobbleGrabberV2Test.java	(date 1608578705741)
+++ TeamCode/src/main/java/Actions/Ultimate/WobbleGrabberV2Test.java	(date 1608578705741)
@@ -0,0 +1,96 @@
+package Actions.Ultimate;
+
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.hardware.DcMotorSimple;
+import com.qualcomm.robotcore.hardware.HardwareMap;
+import com.qualcomm.robotcore.hardware.Servo;
+
+import Actions.ActionHandler;
+import Actions.HardwareWrappers.ServoHandler;
+import MotorControllers.MotorController;
+
+/**
+ * Author: Ethan Fisher
+ * Date: 10/21/2020
+ *
+ * Used for grabbing and releasing the wobble goal
+ */
+public class WobbleGrabberV2Test implements ActionHandler {
+
+    public ServoHandler claw;
+    public MotorController arm;
+
+    private static final double ARM_POWER_DOWN = -.2;
+    private static final double ARM_POWER_UP = .25;
+
+    public static final double CLAW_GRAB_ANGLE = 0.0;
+    public static final double CLAW_RELEASE_ANGLE = .9;
+    public static final double ANGLE_INCREMENT = 25;
+    public static final double GAINS_ANGLE = 0;
+    public static final double LIFT_ANGLE = 0;
+    public static final double GRAB_AND_DROP_ANGLE = 0;
+    public static final double INIT_ANGLE = 0;
+
+    public boolean wobbleGrabbed;
+
+    public WobbleGrabberV2Test(HardwareMap hardwareMap) {
+        claw = new ServoHandler("wobbleGrabberClaw", hardwareMap);
+        claw.setDirection(Servo.Direction.FORWARD);
+
+        try {
+            arm = new MotorController("wobbleGrabberArm", "ActionConfig/WobbleArmConfig.json", hardwareMap);
+            arm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
+            arm.setDirection(DcMotorSimple.Direction.FORWARD);
+            arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        wobbleGrabbed = false;
+    }
+
+    public void grabWobble() {
+        claw.setPosition(CLAW_GRAB_ANGLE);
+    }
+
+    public void releaseWobble() {
+        claw.setPosition(CLAW_RELEASE_ANGLE);
+    }
+
+    public void setArmAngle(double angle) {
+        arm.setPositionDegrees(angle);
+        arm.setMotorPower(ARM_POWER_UP);
+    }
+
+    public void grabWobbleGoal() {
+        claw.setPosition(CLAW_GRAB_ANGLE);
+    }
+
+    public void pause() {
+        arm.brake();
+    }
+
+    public boolean armIsBusy() {
+        return arm.isBusy();
+    }
+
+    @Override
+    public boolean doAction(String action, long maxTimeAllowed) {
+        return false;
+    }
+
+    @Override
+    public boolean stopAction(String action) {
+        return false;
+    }
+
+    @Override
+    public boolean startDoingAction(String action) {
+        return false;
+    }
+
+    @Override
+    public void kill() {
+        arm.killMotorController();
+    }
+}
Index: TeamCode/src/main/java/UserControlled/SpinningMotorTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage UserControlled;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\n\r\n@TeleOp(name=\"Basic: Linear OpMode\", group=\"Testers\")\r\n@Disabled\r\npublic class SpinningMotorTest extends LinearOpMode {\r\n    // create objects and locally global variables here\r\n\r\n    DcMotor wheel;\r\n\r\n    boolean wheelOn = false, aPressed = false;\r\n    boolean bPressed = false;\r\n\r\n    public static final double WHEEL_POWER = 1;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n\r\n        wheel = hardwareMap.dcMotor.get(\"wheelMotor\");\r\n        wheel.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        wheel.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        wheel.setDirection(DcMotorSimple.Direction.FORWARD);\r\n        // initialize objects and variables here\r\n        // also create and initialize function local variables here\r\n\r\n        // add any other useful telemetry data or logging data here\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.update();\r\n        // nothing goes between the above and below lines\r\n        waitForStart();\r\n        // should only be used for a time keeper or other small things, avoid using this space when possible\r\n        while (opModeIsActive()) {\r\n            // main code goes here\r\n\r\n            // button a\r\n            if (gamepad1.a && !aPressed) {\r\n                aPressed = true;\r\n\r\n                wheel.setPower((wheelOn = !wheelOn) ? WHEEL_POWER : 0);\r\n            } else if (!gamepad1.a)\r\n                aPressed = false;\r\n\r\n            // button b\r\n            if (gamepad1.b && !bPressed) {\r\n                bPressed = true;\r\n\r\n                turnMotorAndGrab();\r\n            } else if (!gamepad1.b)\r\n                bPressed = false;\r\n\r\n            // telemetry and logging data goes here\r\n            telemetry.update();\r\n        }\r\n        // disable/kill/stop objects here\r\n    }\r\n    // misc functions here\r\n\r\n    private void turnMotorAndGrab() {\r\n\r\n        // turn motor\r\n\r\n        // grab\r\n\r\n        // return the motor to starting position\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/SpinningMotorTest.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/UserControlled/SpinningMotorTest.java	(date 1608578760628)
@@ -35,7 +35,7 @@
 import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.hardware.DcMotorSimple;
 
-@TeleOp(name="Basic: Linear OpMode", group="Testers")
+@TeleOp(name="Spinning Motor Test", group="Testers")
 @Disabled
 public class SpinningMotorTest extends LinearOpMode {
     // create objects and locally global variables here
Index: TeamCode/src/main/java/UserControlled/GamepadController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package UserControlled;\r\n\r\nimport com.qualcomm.robotcore.hardware.Gamepad;\r\n\r\n/*\r\n    Author: Ethan Fisher\r\n    Date: 10/23/2020\r\n\r\n    Makes it easier to use the gamepads\r\n    For example, if you want to only allow the user to press a button\r\n    and not hold it, this object will allow you to do so\r\n */\r\npublic class GamepadController {\r\n\r\n    private static final double TRIGGER_THRESHOLD = 0.1;\r\n\r\n    private boolean aPressed = false, aHeld = false, bPressed = false, bHeld = false,\r\n            xPressed = false, xHeld = false, yPressed = false, yHeld = false,\r\n            rightBumperPressed = false, rightBumperHeld = false, leftBumperPressed = false,\r\n            leftBumperHeld = false, rightTriggerPressed = false, rightTriggerHeld = false,\r\n            leftTriggerPressed = false, leftTriggerHeld = false, dpadUpPressed = false,\r\n            dpadUpHeld = false, dpadRightPressed = false, dpadRightHeld = false,\r\n            dpadDownPressed = false, dpadDownHeld = false, dpadLeftPressed = false,\r\n            dpadLeftHeld = false, startPressed = false, startHeld = false;\r\n\r\n    public GamepadController(Gamepad gamepad) { update(gamepad); }\r\n\r\n    public void update(Gamepad gamepad) {\r\n\r\n        // update a\r\n        boolean prevAHeld = aHeld;\r\n        aHeld = gamepad.a;\r\n        if (prevAHeld) aPressed = false;\r\n        if (!prevAHeld && aHeld) aPressed = true;\r\n\r\n        // update b\r\n        boolean prevBHeld = bHeld;\r\n        bHeld = gamepad.b;\r\n        if (prevBHeld) bPressed = false;\r\n        if (!prevBHeld && bHeld) bPressed = true;\r\n\r\n        // update x\r\n        boolean prevXHeld = xHeld;\r\n        xHeld = gamepad.x;\r\n        if (prevXHeld) xPressed = false;\r\n        if (!prevXHeld && xHeld) xPressed = true;\r\n\r\n        // update y\r\n        boolean prevYHeld = yHeld;\r\n        yHeld = gamepad.y;\r\n        if (prevYHeld) yPressed = false;\r\n        if (!prevYHeld && yHeld) yPressed = true;\r\n\r\n        // update right bumper\r\n        boolean prevRightBumperHeld = rightBumperHeld;\r\n        rightBumperHeld = gamepad.right_bumper;\r\n        if (prevRightBumperHeld) rightBumperPressed = false;\r\n        if (!prevRightBumperHeld && rightBumperHeld) rightBumperPressed = true;\r\n\r\n        // update left bumper\r\n        boolean prevLeftBumperHeld = leftBumperHeld;\r\n        leftBumperHeld = gamepad.left_bumper;\r\n        if (prevLeftBumperHeld) leftBumperPressed = false;\r\n        if (!prevLeftBumperHeld && leftBumperHeld) leftBumperPressed = true;\r\n\r\n        //update right trigger\r\n        boolean prevRightTriggerHeld = rightTriggerHeld;\r\n        rightTriggerHeld = isTriggerHeld(gamepad.right_trigger);\r\n        if (prevRightTriggerHeld) rightTriggerPressed = false;\r\n        if (!prevRightTriggerHeld && rightTriggerHeld) rightTriggerPressed = true;\r\n\r\n        //update left trigger\r\n        boolean prevLeftTriggerHeld = leftTriggerHeld;\r\n        leftTriggerHeld = isTriggerHeld(gamepad.left_trigger);\r\n        if (prevLeftTriggerHeld) leftTriggerPressed = false;\r\n        if (!prevLeftTriggerHeld && leftTriggerHeld) leftTriggerPressed = true;\r\n\r\n        // update d pad up\r\n        boolean prevDPadUpHeld = dpadUpHeld;\r\n        dpadUpHeld = gamepad.dpad_up;\r\n        if (prevDPadUpHeld) dpadUpPressed = false;\r\n        if (!prevDPadUpHeld && dpadUpHeld) dpadUpPressed = true;\r\n\r\n        // update d pad right\r\n        boolean prevDPadRightHeld = dpadRightHeld;\r\n        dpadRightHeld = gamepad.dpad_right;\r\n        if (prevDPadRightHeld) dpadRightPressed = false;\r\n        if (!prevDPadRightHeld && dpadRightHeld) dpadRightPressed = true;\r\n\r\n        // update d pad down\r\n        boolean prevDPadDownHeld = dpadDownHeld;\r\n        dpadDownHeld = gamepad.dpad_down;\r\n        if (prevDPadDownHeld) dpadDownPressed = false;\r\n        if (!prevDPadDownHeld && dpadDownHeld) dpadDownPressed = true;\r\n\r\n        // update d pad left\r\n        boolean prevDPadLeftHeld = dpadLeftHeld;\r\n        dpadLeftHeld = gamepad.dpad_left;\r\n        if (prevDPadLeftHeld) dpadLeftPressed = false;\r\n        if (!prevDPadLeftHeld && dpadLeftHeld) dpadLeftPressed = true;\r\n\r\n        // update start button\r\n        boolean prevStartHeld = startHeld;\r\n        startHeld = gamepad.start;\r\n        if (prevStartHeld) startPressed = false;\r\n        if (!prevStartHeld && startHeld) startPressed = true;\r\n    }\r\n\r\n    // getters for all of the \"pressed\" and \"held\" values\r\n    public boolean aPressed() { return aPressed; }\r\n    public boolean aHeld() { return aHeld; }\r\n    public boolean bPressed() { return bPressed; }\r\n    public boolean bHeld() { return bHeld; }\r\n    public boolean xPressed() { return xPressed; }\r\n    public boolean xHeld() { return xHeld; }\r\n    public boolean yPressed() { return yPressed; }\r\n    public boolean yHeld() { return yHeld; }\r\n    public boolean rightBumperPressed() { return rightBumperPressed; }\r\n    public boolean rightBumperHeld() { return rightBumperHeld; }\r\n    public boolean leftBumperPressed() { return leftBumperPressed; }\r\n    public boolean leftBumperHeld() { return leftBumperHeld; }\r\n    public boolean rightTriggerPressed() { return rightTriggerPressed; }\r\n    public boolean rightTriggerHeld() { return rightTriggerHeld; }\r\n    public boolean leftTriggerPressed() { return leftTriggerPressed; }\r\n    public boolean leftTriggerHeld() { return leftTriggerHeld; }\r\n    public boolean dpadUpPressed() { return dpadUpPressed; }\r\n    public boolean dpadUpHeld() { return dpadUpHeld; }\r\n    public boolean dpadRightPressed() { return dpadRightPressed; }\r\n    public boolean dpadRightHeld() { return dpadRightHeld; }\r\n    public boolean dpadDownPressed() { return dpadDownPressed; }\r\n    public boolean dpadDownHeld() { return dpadDownHeld; }\r\n    public boolean dpadLeftPressed() { return dpadLeftPressed; }\r\n    public boolean dpadLeftHeld() { return dpadLeftHeld; }\r\n    public boolean startPressed() { return startPressed; }\r\n    public boolean startHeld() { return startHeld; }\r\n\r\n    private boolean isTriggerHeld(double trigger) {\r\n        if (trigger > TRIGGER_THRESHOLD)\r\n            return true;\r\n        return false;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/GamepadController.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/UserControlled/GamepadController.java	(date 1608573596075)
@@ -12,6 +12,8 @@
  */
 public class GamepadController {
 
+    private Gamepad gamepad;
+
     private static final double TRIGGER_THRESHOLD = 0.1;
 
     private boolean aPressed = false, aHeld = false, bPressed = false, bHeld = false,
@@ -23,9 +25,9 @@
             dpadDownPressed = false, dpadDownHeld = false, dpadLeftPressed = false,
             dpadLeftHeld = false, startPressed = false, startHeld = false;
 
-    public GamepadController(Gamepad gamepad) { update(gamepad); }
+    public GamepadController(Gamepad gamepad) { this.gamepad = gamepad; update(); }
 
-    public void update(Gamepad gamepad) {
+    public void update() {
 
         // update a
         boolean prevAHeld = aHeld;
Index: TeamCode/src/main/java/UserControlled/Ultimate/UltimateV2Better.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/UserControlled/Ultimate/UltimateV2Better.java	(date 1608581092600)
+++ TeamCode/src/main/java/UserControlled/Ultimate/UltimateV2Better.java	(date 1608581092600)
@@ -0,0 +1,267 @@
+/* Copyright (c) 2017 FIRST. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted (subject to the limitations in the disclaimer below) provided that
+ * the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this list
+ * of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * Neither the name of FIRST nor the names of its contributors may be used to endorse or
+ * promote products derived from this software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package UserControlled.Ultimate;
+
+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
+
+import Actions.Ultimate.RingIntakeSystemV2Test;
+import Actions.Ultimate.ShooterSystemV1;
+import Actions.Ultimate.ShooterSystemV2Test;
+import Actions.Ultimate.WobbleGrabberV2Test;
+import Autonomous.ConfigVariables;
+import Autonomous.Location;
+import DriveEngine.Ultimate.UltimateNavigation;
+import UserControlled.JoystickHandler;
+
+/**
+ * Author: Software Team 2020-2021
+ *
+ * Controls the Ultimate Goal Robot
+ *
+ * -------------- TLDR ---------------
+ * Player One:
+ *      joysticks - drive base
+ *      start - N/A
+ *      a - N/A
+ *      b - N/A
+ *      x - N/A
+ *      y - N/A
+ *      dpad up/down/left/right - auto power shots
+ *      right trigger - shoot
+ *      left trigger - slow mode
+ *
+ * Player Two:
+ *      joysticks - N/A
+ *      a - toggle intake
+ *      b - toggle outake
+ *      x - toggle shooter
+ *      y - toggle wobble grabber
+ *      dpad up/down/left/right - wobble grabber positions
+ *      right trigger - drop intake
+ *      left trigger - N/A
+ */
+
+@TeleOp(name="Ultimate V2", group="Competition")
+//@Disabled
+public class UltimateV2Better extends LinearOpMode {
+
+    // TODO add speed values and angles when using the wobble grabber
+
+    // create objects and locally global variables here
+    UltimateNavigation robot;
+    JoystickHandler leftStick, rightStick;
+
+    RingIntakeSystemV2Test intake;
+    ShooterSystemV2Test shooter;
+    WobbleGrabberV2Test grabber;
+
+    boolean eStop = false, slowMode = false, intakeOn = false, outakeOn = false, shooterOn = false, wobbleGrabbed = false, a2Pressed = false, b2Pressed = false, x2Pressed = false, y2Pressed = false;
+
+    @Override
+    public void runOpMode() {
+        // initialize objects and variables here
+        // also create and initialize function local variables here
+
+        // initialize robot
+        // TODO get starting angle
+        try {
+            robot = new UltimateNavigation(hardwareMap, new Location(0, 0, 0), "RobotConfig/UltimateV1.json");
+        } catch (Exception e) {
+            telemetry.addData("Robot Error", e.toString());
+            telemetry.update();
+        }
+
+        // initialize systems
+        intake = new RingIntakeSystemV2Test(hardwareMap);
+        shooter = new ShooterSystemV2Test(hardwareMap);
+        grabber = new WobbleGrabberV2Test(hardwareMap);
+
+        // initialize joysticks
+        leftStick = new JoystickHandler(gamepad1, JoystickHandler.LEFT_JOYSTICK);
+        rightStick = new JoystickHandler(gamepad1, JoystickHandler.RIGHT_JOYSTICK);
+
+        // add any other useful telemetry data or logging data here
+        telemetry.addData("Status", "Initialized");
+        telemetry.update();
+
+        // nothing goes between the above and below lines
+
+        waitForStart();
+
+        // puts the pinball servo on the outside
+        shooter.pinballServo.setPosition(ShooterSystemV1.PINBALL_REST);
+        shooter.update();
+
+        // should only be used for a time keeper or other small things, avoid using this space when possible
+        while (opModeIsActive()) {
+            // main code goes here
+
+            updateEStop();
+            if (!eStop) {
+                updateEStop();
+                controlDrive();
+
+                updateEStop();
+                if (!eStop) {
+                    playerOneFunctions();
+                    playerTwoFunctions();
+                }
+            }
+
+            if (eStop)
+                stopActions();
+
+            // telemetry and logging data goes here
+            telemetry.update();
+        }
+
+        // disable/kill/stop objects here
+        robot.stopNavigation();
+
+    }
+
+    // misc functions here
+    private void updateEStop() {
+        if ((gamepad1.dpad_down && gamepad1.start) || (gamepad2.dpad_down && gamepad2.start))
+            eStop = !eStop;
+    }
+
+    private void controlDrive() {
+        if(gamepad1.left_trigger > 0.1) slowMode = true;
+        else slowMode = false;
+        double drivePower = slowMode ? leftStick.magnitude() / 3 : leftStick.magnitude();
+        double turnPower = slowMode ? rightStick.x() / 4 : rightStick.x();
+        if (!eStop)
+            robot.driveOnHeadingWithTurning(leftStick.angle(), drivePower, turnPower);
+    }
+
+    private void playerOneFunctions() {
+        if(gamepad1.dpad_up) powerShots();
+        else if(gamepad1.dpad_left) powerShotLeft();
+        else if(gamepad1.dpad_down) powerShotCenter();
+        else if(gamepad1.dpad_right) powerShotRight();
+
+        if(gamepad1.right_trigger > 0.1) shooter.shoot();
+
+        // TODO: update this to be actually correct, need to determine which wall to be against and what the x and y values would be
+        if(gamepad1.x) {
+            robot.setLocation(new Location(0, robot.getRobotLocation().getY()));
+        } else if(gamepad1.y) {
+            robot.setLocation(new Location(robot.getRobotLocation().getX(), 0));
+        }
+    }
+
+    private void playerTwoFunctions() {
+        if(gamepad2.a && !a2Pressed) {
+            a2Pressed = true;
+            intakeOn = !intakeOn;
+            outakeOn = false;
+        } else if(!gamepad2.a) {
+            a2Pressed = false;
+        } else if(gamepad2.b && !b2Pressed) {
+            b2Pressed = true;
+            outakeOn = !outakeOn;
+            intakeOn = false;
+        } else if(!gamepad2.b) {
+            b2Pressed = false;
+        }
+
+        if(gamepad2.x && !x2Pressed) {
+            x2Pressed = true;
+            shooterOn = !shooterOn;
+        } else if(!gamepad2.x) {
+            x2Pressed = false;
+        }
+
+        if(gamepad2.y && !y2Pressed) {
+            y2Pressed = true;
+            wobbleGrabbed = !wobbleGrabbed;
+        } else if(!gamepad2.y) {
+            y2Pressed = false;
+        }
+
+        if(gamepad2.dpad_up) {
+            grabber.setArmAngle(WobbleGrabberV2Test.GAINS_ANGLE);
+        } else if(gamepad2.dpad_right) {
+            grabber.setArmAngle(WobbleGrabberV2Test.LIFT_ANGLE);
+        } else if(gamepad2.dpad_down) {
+            grabber.setArmAngle(WobbleGrabberV2Test.GRAB_AND_DROP_ANGLE);
+        } else if(gamepad2.dpad_left) {
+            grabber.setArmAngle(WobbleGrabberV2Test.INIT_ANGLE);
+        }
+//        if(gamepad2.right_trigger > 0.1) intake.drop();
+        if(intakeOn) intake.intake();
+        else if(outakeOn) intake.spit();
+        else intake.pause();
+        if(wobbleGrabbed) grabber.grabWobble();
+        else if(!wobbleGrabbed) grabber.releaseWobble();
+        if(shooterOn) shooter.turnOnShooterWheel();
+        else if(!shooterOn) shooter.turnOffShooterWheel();
+        shooter.update();
+    }
+
+    private void powerShots() {
+        powerShotLeft();
+        powerShotCenter();
+        powerShotRight();
+    }
+
+    private void powerShotLeft() {
+        shooter.turnOnShooterWheel();
+        robot.driveToLocation(ConfigVariables.POWER_SHOT_LEFT_ON_LINE, 25, this);
+        shooter.shoot();
+        sleep(10);
+        shooter.shoot();
+    }
+
+    private void powerShotCenter() {
+        shooter.turnOnShooterWheel();
+        robot.driveToLocation(ConfigVariables.POWER_SHOT_MIDDLE_ON_LINE, 25, this);
+        shooter.shoot();
+        sleep(10);
+        shooter.shoot();
+    }
+
+    private void powerShotRight() {
+        shooter.turnOnShooterWheel();
+        robot.driveToLocation(ConfigVariables.POWER_SHOT_RIGHT_ON_LINE, 25, this);
+        shooter.shoot();
+        sleep(10);
+        shooter.shoot();
+    }
+
+    private void stopActions() {
+        robot.brake();
+        intake.pause();
+        grabber.pause();
+        shooter.turnOffShooterWheel();
+    }
+}
Index: TeamCode/src/main/java/Actions/Ultimate/RingIntakeSystemV2Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/Actions/Ultimate/RingIntakeSystemV2Test.java	(date 1608578705732)
+++ TeamCode/src/main/java/Actions/Ultimate/RingIntakeSystemV2Test.java	(date 1608578705732)
@@ -0,0 +1,58 @@
+package Actions.Ultimate;
+
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.hardware.DcMotorSimple;
+import com.qualcomm.robotcore.hardware.HardwareMap;
+
+import java.io.IOException;
+
+import Actions.ActionHandler;
+import MotorControllers.MotorController;
+
+public class RingIntakeSystemV2Test implements ActionHandler {
+
+    private MotorController intakeMotor;
+
+    public RingIntakeSystemV2Test(HardwareMap hardwareMap) {
+        try {
+            intakeMotor = new MotorController("intakeMotor", "MotorConfig/NoLoad40.json", hardwareMap);
+            intakeMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
+            intakeMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
+            intakeMotor.setDirection(DcMotorSimple.Direction.FORWARD);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void intake() {
+        intakeMotor.setMotorPower(1);
+    }
+
+    public void spit() {
+        intakeMotor.setMotorPower(-1);
+    }
+
+    public void pause() {
+        intakeMotor.brake();
+    }
+
+    @Override
+    public boolean doAction(String action, long maxTimeAllowed) {
+        return false;
+    }
+
+    @Override
+    public boolean stopAction(String action) {
+        return false;
+    }
+
+    @Override
+    public boolean startDoingAction(String action) {
+        return false;
+    }
+
+    @Override
+    public void kill() {
+        intakeMotor.killMotorController();
+    }
+}
Index: TeamCode/src/main/java/Autonomous/VisionHelperUltimateGoal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Autonomous;\r\n\r\nimport android.util.Log;\r\n\r\nimport com.qualcomm.hardware.rev.RevBlinkinLedDriver;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\r\nimport org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\r\nimport org.firstinspires.ftc.robotcore.external.matrices.VectorF;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\r\nimport static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\r\nimport static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\r\nimport static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\r\n\r\n/**\r\n * Created by robotics on 12/18/18.\r\n */\r\n\r\npublic class VisionHelperUltimateGoal extends Thread {\r\n    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\r\n    private static final String LABEL_QUAD_STACK = \"Quad\";\r\n    private static final String LABEL_SINGLE_STACK = \"Single\";\r\n    public final static int SLEEP_TIME_MILLIS = 200;\r\n    public final static int PHONE_CAMERA = 0;\r\n    public final static int WEBCAM = 1;\r\n    public final static int LOCATION = 0, RING_DETECTION = 1, BOTH = 2;\r\n    VuforiaLocalizer vuforia;\r\n    VuforiaTrackables targetsUltimateGoal;\r\n    VuforiaTrackable blueTowerGoalTarget;\r\n    VuforiaTrackable redTowerGoalTarget;\r\n    VuforiaTrackable redAllianceTarget;\r\n    VuforiaTrackable blueAllianceTarget;\r\n    VuforiaTrackable frontWallTarget;\r\n    private volatile TFObjectDetector tfod;\r\n    private volatile boolean running = true, trackingLocation = false;\r\n    private volatile boolean findingRings = false;\r\n    private volatile boolean targetVisible = false;\r\n    private volatile OpenGLMatrix lastLocation = null;\r\n    private volatile OpenGLMatrix lastRingLocation = null;\r\n    private volatile Location robotLocation = new Location(0, 0);\r\n    private volatile Location ringLocation = new Location(0, 0);\r\n    private volatile Orientation ringOrientation;\r\n    List<VuforiaTrackable> allTrackables;\r\n    Orientation robotOrientation;\r\n    VectorF translation;\r\n    VectorF ringTranslation;\r\n    private int mode = LOCATION;\r\n    private int numOfRings = 0;\r\n    private RevBlinkinLedDriver LEDStripController;\r\n\r\n    private static final float mmPerInch        = 25.4f;\r\n    private static final float mmFTCFieldWidth  = (12*6) * mmPerInch;  // the width of the FTC field (from the center point to the outer panels)\r\n    private static final float mmTargetHeight   = (5.75f) * mmPerInch;    // the height of the center of the target image above the floor\r\n\r\n    // Constants for perimeter targets\r\n    private static final float halfField = 72 * mmPerInch;\r\n    private static final float quadField  = 36 * mmPerInch;\r\n\r\n    final int CAMERA_FORWARD_DISPLACEMENT_FROM_CENTER = (int)(1.5*mmPerInch);\r\n    final int CAMERA_VERTICAL_DISPLACEMENT_FROM_CENTER = (int)(14*mmPerInch);\r\n    final int CAMERA_LEFT_DISPLACEMENT_FROM_CENTER = (int)(-mmPerInch);\r\n\r\n    public VisionHelperUltimateGoal(int camera, HardwareMap hardwareMap) { this(camera, BOTH, hardwareMap); }\r\n\r\n    public VisionHelperUltimateGoal(int camera, int mode, HardwareMap hardwareMap) {\r\n        this.mode = mode;\r\n        switch (mode) {\r\n            case LOCATION:\r\n                vuforia = VuforiaHelper.initVuforia(camera, hardwareMap);\r\n                break;\r\n            case RING_DETECTION:\r\n            case BOTH:\r\n                initBoth(camera, hardwareMap);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        LEDStripController = hardwareMap.get(RevBlinkinLedDriver.class, \"LEDStripController\");\r\n        LEDStripController.resetDeviceConfigurationForOpMode();\r\n        LEDStripController.setPattern(RevBlinkinLedDriver.BlinkinPattern.BLACK);\r\n    }\r\n\r\n    private void initBoth(int camera, HardwareMap hardwareMap) {\r\n        try {\r\n            vuforia = VuforiaHelper.initVuforia(camera, hardwareMap);\r\n            int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\r\n                    \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n            TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\r\n            tfodParameters.minResultConfidence = 0.8f;\r\n            tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\r\n            tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_QUAD_STACK, LABEL_SINGLE_STACK);\r\n        } catch (Exception e) {\r\n            Log.e(\"VisionHelper Error\", e.toString());\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    public void setLEDMode(RevBlinkinLedDriver.BlinkinPattern pattern) {\r\n        LEDStripController.setPattern(pattern);\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        while (running) {\r\n            if (trackingLocation) updateRobotLocation();\r\n//                if (findingSkyStone) getStonesInView();\r\n            if (findingRings) countRings();\r\n            try {\r\n                sleep(SLEEP_TIME_MILLIS);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void startDetection() {\r\n        loadNavigationAssets();\r\n        robotOrientation = new Orientation(EXTRINSIC, XYZ, DEGREES, 0, 0, 0, 0);\r\n        running = true;\r\n        findingRings = true;\r\n        this.start();\r\n    }\r\n\r\n    public void stopDetection() {\r\n        findingRings = false;\r\n        running = false;\r\n    }\r\n\r\n    public void startFindingRings() { findingRings = true; }\r\n\r\n    public void startTrackingLocation() {\r\n        trackingLocation = true;\r\n    }\r\n\r\n    public void stopTrackingLocation() { trackingLocation = false; }\r\n\r\n    public Recognition[] getRingsInView() {\r\n        return tfod.getRecognitions().toArray(new Recognition[0]);\r\n    }\r\n\r\n    public void countRings() {\r\n        Recognition[] rings = getRingsInView();\r\n        for(Recognition r : rings) {\r\n            if(r.getLabel().equals(LABEL_SINGLE_STACK)) numOfRings = 1;\r\n            else if(r.getLabel().equals(LABEL_QUAD_STACK)) numOfRings = 4;\r\n            else numOfRings = 0;\r\n        }\r\n    }\r\n\r\n    public int numOfSeenRings() { return numOfRings; }\r\n\r\n    public Orientation getRobotOrientation() {\r\n        return robotOrientation;\r\n    }\r\n\r\n    public double getRobotHeading() {\r\n//        double heading = -robotOrientation.thirdAngle;\r\n//        return heading;\r\n        return -robotOrientation.thirdAngle;\r\n    }\r\n\r\n    public Location getRobotLocation() {\r\n        if(trackingLocation) return robotLocation;\r\n        else return null;\r\n    }\r\n\r\n    private void updateRobotLocation() {\r\n        targetVisible = false;\r\n        for (VuforiaTrackable trackable : allTrackables) {\r\n            if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\r\n                targetVisible = true;\r\n\r\n                OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\r\n                if (robotLocationTransform != null) {\r\n                    lastLocation = robotLocationTransform;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (targetVisible) {\r\n            translation = lastLocation.getTranslation();\r\n            robotLocation = new Location(0, 0);\r\n            robotLocation.update(translation.get(0) / mmPerInch, translation.get(1) / mmPerInch);\r\n            robotOrientation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);\r\n        } else {\r\n            robotLocation = null;\r\n            robotOrientation = null;\r\n        }\r\n    }\r\n\r\n    public void loadNavigationAssets() {\r\n        targetsUltimateGoal = vuforia.loadTrackablesFromAsset(\"UltimateGoal\"); // NOTE: the asset is titled Skystone not SkyStone... this is why I told you to copy and paste...\r\n        blueTowerGoalTarget = targetsUltimateGoal.get(0);\r\n        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\r\n        redTowerGoalTarget = targetsUltimateGoal.get(1);\r\n        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\r\n        redAllianceTarget = targetsUltimateGoal.get(2);\r\n        redAllianceTarget.setName(\"Red Alliance Target\");\r\n        blueAllianceTarget = targetsUltimateGoal.get(3);\r\n        blueAllianceTarget.setName(\"Blue Alliance Target\");\r\n        frontWallTarget = targetsUltimateGoal.get(4);\r\n        frontWallTarget.setName(\"Front Wall Target\");\r\n\r\n        allTrackables = new ArrayList<>();\r\n        allTrackables.addAll(targetsUltimateGoal);\r\n\r\n        redAllianceTarget.setLocation(OpenGLMatrix\r\n                .translation(0, -halfField, mmTargetHeight)\r\n                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\r\n\r\n        blueAllianceTarget.setLocation(OpenGLMatrix\r\n                .translation(0, halfField, mmTargetHeight)\r\n                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\r\n        frontWallTarget.setLocation(OpenGLMatrix\r\n                .translation(-halfField, 0, mmTargetHeight)\r\n                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0 , 90)));\r\n\r\n        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\r\n        blueTowerGoalTarget.setLocation(OpenGLMatrix\r\n                .translation(halfField, quadField, mmTargetHeight)\r\n                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0 , -90)));\r\n        redTowerGoalTarget.setLocation(OpenGLMatrix\r\n                .translation(halfField, -quadField, mmTargetHeight)\r\n                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\r\n\r\n        OpenGLMatrix cameraLocationOnRobot = OpenGLMatrix\r\n                .translation(CAMERA_FORWARD_DISPLACEMENT_FROM_CENTER, CAMERA_LEFT_DISPLACEMENT_FROM_CENTER, CAMERA_VERTICAL_DISPLACEMENT_FROM_CENTER)\r\n                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES,\r\n                        90, 0, 90));\r\n\r\n        for (VuforiaTrackable trackable : allTrackables)\r\n            ((VuforiaTrackableDefaultListener)trackable.getListener()).setCameraLocationOnRobot(vuforia.getCameraName(), cameraLocationOnRobot);\r\n\r\n        targetsUltimateGoal.activate();\r\n        if (tfod != null) {\r\n            tfod.activate();\r\n        }\r\n    }\r\n\r\n    public void kill() {\r\n        stopDetection();\r\n        targetsUltimateGoal.deactivate();\r\n        if(mode == BOTH || mode == RING_DETECTION) tfod.shutdown();\r\n//        VuforiaHelper.kill();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/Autonomous/VisionHelperUltimateGoal.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/Autonomous/VisionHelperUltimateGoal.java	(date 1608578705724)
@@ -114,6 +114,7 @@
 
     @Override
     public void run() {
+        if(findingRings) cycleRingDetection();
         while (running) {
             if (trackingLocation) updateRobotLocation();
 //                if (findingSkyStone) getStonesInView();
@@ -160,6 +161,12 @@
         }
     }
 
+    public void cycleRingDetection() {
+        for(int i = 0; i < 10; i++) {
+            getRingsInView();
+        }
+    }
+
     public int numOfSeenRings() { return numOfRings; }
 
     public Orientation getRobotOrientation() {
Index: TeamCode/src/main/java/Autonomous/OpModes/Tests/DetectRingsTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Autonomous.OpModes.Tests;\r\n\r\nimport android.graphics.Bitmap;\r\nimport android.util.Log;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\n\r\nimport java.util.ArrayList;\r\n\r\nimport Autonomous.VisionHelperUltimateGoal;\r\nimport Autonomous.VuforiaHelper;\r\n\r\n/**\r\n * Created by root on 11/20/17.\r\n */\r\n\r\n/*\r\n    An opmode to test saving images using vuforia\r\n */\r\n@Autonomous(name=\"Detect Rings Test\", group=\"Testers\")  // @Autonomous(...) is the other common choice\r\n//@Disabled\r\npublic class DetectRingsTest extends LinearOpMode {\r\n\r\n    VisionHelperUltimateGoal ringFinder;\r\n    @Override\r\n    public void runOpMode() throws InterruptedException {\r\n\r\n        ringFinder = new VisionHelperUltimateGoal(VisionHelperUltimateGoal.WEBCAM, VisionHelperUltimateGoal.BOTH, hardwareMap);\r\n        ringFinder.startDetection();\r\n\r\n        telemetry.addData(\"Status\",\"Initialized\");\r\n        telemetry.addData(\"Rings\", ringFinder.numOfSeenRings());\r\n        telemetry.update();\r\n        waitForStart();\r\n\r\n        while (opModeIsActive()) {\r\n            telemetry.addData(\"Rings\", ringFinder.numOfSeenRings());\r\n            telemetry.update();\r\n        }\r\n        ringFinder.kill();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/Autonomous/OpModes/Tests/DetectRingsTest.java	(revision fb18cbc86d3a3a8921f116f23f8debcc4a96ade7)
+++ TeamCode/src/main/java/Autonomous/OpModes/Tests/DetectRingsTest.java	(date 1608578705728)
@@ -40,11 +40,4 @@
         }
         ringFinder.kill();
     }
-
-
-
-
-
-
-
 }
